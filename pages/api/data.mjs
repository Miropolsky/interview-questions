export const questions = [
    {
        question: "Что происходит, когда мы ввели адрес сайта и нажали Enter?",
        answer: `Сначала нам нужно найти ip адрес сервера с которого мы получим Html документ. Сначала мы смотрим в кеше браузера, если его нет, то мы смотрим в кеше системы, если там нет, то дальше ищется в кеше роутера, если нет то мы идем к DNS серверу, чтобы получить ip адрес. Дальше начинается этап тройного рукопожатия. После этого идем на сервер чтобы получить htmlку. И она отдается (Браузер понимает что это html по заголовку, content-type:  text/html). Дальше из полученного Html документа у нас формируется DOM, CSSOM, Рендер Три(объединяются DOM и CSSOM), дальше происходит этап Layout(рассчитывается размеры, положения элементов, вычисление слоев), после этого этап Compositing(когда все слои объединяются в один слой), дальше этап Paint(применяются background, color), и в конце этап display(Когда показываем что-то пользователю на странице).

        Также существуют блокирующие скрипты и не блокирующие.Они встречаются при парсинге DOMа.Если есть тег скрипт в Html коде, то парсинг останавливается чтобы выполнить скрипты, задерживается построение DOM. 
        Этого можно избежать если использовать атрибуты Async и Defer:
            1)Async - JS скачивается параллельно, не блокирует парсинг, запускается сразу как загрузился.То есть нет гарантии что скрипты будут выполняться последовательно.Например можно использовать для яндекс метрики.
            2) Defer - Не блокирует парсинг HTML, скачивается параллельно.Когда событие DomContentLoaded стрельнуло, и мы точно убедились что DOM построен, выполняются все скрипты.Используется для скриптов, которые зависят от DOM, например, когда скрипт должен манипулировать элементами HTML.`,
        categories: ['platina1', 'js', 'react', "all"]
    },
    {
        question: "Что делают атрибуты Async и Defer?",
        answer: `1)Async - JS скачивается параллельно, не блокирует парсинг, запускается сразу как загрузился.То есть нет гарантии что скрипты будут выполняться последовательно.Например можно использовать для яндекс метрики.
            2) Defer - Не блокирует парсинг HTML, скачивается параллельно.Когда событие DomContentLoaded стрельнуло, и мы точно убедились что DOM построен, выполняются все скрипты.Используется для скриптов, которые зависят от DOM, например, когда скрипт должен манипулировать элементами HTML.`,
        categories: ["js", 'platina1', "all"]
    },
    {
        question: "Что такое Рендер три",
        answer: `Рендер три - дерево рендеринга – представление DOM и CSSOM (отображение их вместе, дерево дом нод со стилями к ним)`,
        categories: ["react", "js", 'platina1', "all"]
    },
    {
        question: "Что такое этап Layout?",
        answer: `Layout - в этом этапе для каждого элемента рассчитывается его положение, размер, расчет взаиморасположении элементов на слое, расчет влияния одних элементов на других, вычисление слоев(например свойство трансформ выносится в отдельный слой)
`,
        categories: ['platina1', 'js', 'react', "all"]
    },
    {
        question: "Как эффективнее сделать анимацию: через transform/translate или через left?",
        answer: `Через транформ/транслейт, потому что она использует графический редактор(GPU), а не центральный процессор(CPU). Изменения через transform затрагивают только этапы compositing и painting, в то время как изменение left вызывает этап layout, что вызывает пересчет элементов на странице.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Что такое DOM?",
        answer: `Объектная модель документа, которую браузер создает в памяти компьютера, на основании html, который мы получили с сервера. Иными словами, это представление html в виде дерева тегов.
        Основные узлы дом дерева – это html теги(div, p, a), текстовые узлы и атрибутные узлы(класс, айди). DOM нужен для динамического изменения содержимого страницы, взаимодействия с HTML-документом и обновления его структуры. Через DOM API предоставляется доступ к различным объектам, что позволяет изменять атрибуты и стили элементов, а также создавать и удалять их.`,
        categories: ["js", 'react', 'platina1', "all"]
    },
    {
        question: "Что такое CSSOM?",
        answer: `CSSOM (CSS Object Model) — это структура, которая представляет собой объектную модель стилей, аналогичную DOM, но для CSS. Она создаётся браузером параллельно с DOM и описывает все стили, которые будут применяться к элементам на странице.`,
        categories: ["htmlcss", 'js', 'react', 'platina1', "all"]
    },
    {
        question: "Что такое CSS In JS?",
        answer: `Подход, который позволяет писать CSS внутри JavaScript. В React стили можно описывать как обычные JavaScript объекты, а затем применять их к компонентам. С помощью такого подхода можно создавать компоненты, которые динамически меняют стили, в зависимости от переданных пропсов.
        Из плюсов: Вендорные префиксы добавляются автоматически  для кроссбраузерной совместимости(например, -webkit-, -moz-, -ms-, -o-), Динамические стили(Легко изменять стили компонентов в зависимости от пропсов)
        Из минусов: увеличение размера JavaScript(его надо подгрузить, распарсить, выполнять, собрать все теги) Дольше отрисовка чем у CSS, неудобно, нельзя разбить на чанки
`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Cors и какие проблемы он решает?",
        answer: `CORS (Cross-Origin Resource Sharing) — это механизм, который позволяет браузерам запрашивать ресурсы с другого домена, отличного от того, с которого загружается страница. По умолчанию в браузере политика Same-Origin Policy, которая запрещает читать другие ответы от других источников, которые отличаются от источника, с которого был запрос. 
        CORS защищает приложения от потенциальных угроз, обеспечивая, что запросы могут быть отправлены только к безопасным и проверенным источникам. Это предотвращает атаки межсайтового скриптинга(XSS) и подделки запросов(CSRF).
        Когда страница пытается сделать запрос к ресурсу с другого домена, браузер сначала отправляет предварительный запрос (preflight) с методом OPTIONS, чтобы проверить, разрешает ли сервер доступ. Если сервер отвечает с заголовком Access-Control-Allow-Origin и указывает домен, с которого разрешены запросы, браузер позволит доступ к этому ресурсу. Например, Если стучимся на бек и в консоле ошибка по корсу. То идем к бекендерам и просим добавить наш url фронта в access control allow origin.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Какие есть методы HTTP?",
        answer: `1) GET: Используется для получения данных с сервера. Особенности: Запросы кешируются, передаются параметры через URL (query string), нет тела запроса. 
                 2) POST: Используется для создания новой сущности на сервере. Особенности: Данные передаются в теле запроса. POST-запросы не кешируются. (POST также может использоваться для получения данных, хотя это нарушает принцип REST)
                3) PUT: Используется для полного обновления ресурса. Особенности: Полностью заменяет существующую сущность новыми данными. 
                4) PATCH: Используется для частичного обновления ресурса. Особенности: Обновляет только указанные поля сущности. 
                5) DELETE: Используется для удаления ресурса.
                6) OPTIONS: Используется для получения информации о доступных методах для ресурса. Особенности: Часто используется для предварительных запросов (preflight) в контексте CORS. Браузер отправляет запрос OPTIONS перед отправкой сложного запроса (например, с токенами авторизации), чтобы убедиться, что сервер разрешает запрашиваемый метод.
                7) HEAD: Используется для проверки наличия ресурса или метаинформации (например, заголовков) без загрузки контента. Особенности: Аналогичен методу GET, но без тела ответа.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Отличие Put от Patch?",
        answer: `Put полностью заменяет ресурс, а patch – обновляет конкретные значения(вносит частичные изменения).`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Отличие Get от Post?",
        answer: `get - используется для запроса данных. Не безопасен для передачи конфиденциальных данных, так как передает параметры в URL, может быть кеширован, идемпотентен. есть Etag. А post используется для создания новой сущности. Данные передаются в теле запроса, не кэшируется, не является идемпотентным.`,
        categories: ["technology", 'react', 'js', 'platina1', , "all"]
    },
    {
        question: "Что такое идемпотентность?",
        answer: `идемпотентный –  многократное выполнение запроса приводит к одному и тому же результату, что и при первом выполнении.
        1) GET: многократное получение ресурса не изменяет состояние сервера.
        2) PUT: многократное обновление ресурса одними и теми же данными приводит к одному и тому же результату.
        3) DELETE: многократное удаление ресурса приводит к одному и тому же результату.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое ETag(ентитег)?",
        answer: `Etag(энтити тег) – Это уникальный хэш, который сервер добавляет к ответу для определения изменения ресурса. Если хэш не изменился, то клиент может использовать данные из кеша.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Preflight запрос?",
        answer: `Preflight запрос — это специальный запрос, который отправляется перед основным запросом к серверу. Он использует метод OPTIONS и содержит заголовки, такие как Access-Control-Request-Method и Origin, которые информируют сервер о типе предстоящего запроса и происхождении запроса. (Пример: отправка запроса с токеном авторизации в заголовке)`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое SSR? Плюсы и минусы?",
        answer: `Server Side Rendering. Клиенту с сервера отдается готовый html. Скачивается CSS, затем JS. Дальше идет этап гидратации(Когда нужно наложить JS на HTML для функциональности и интерактивности)
        Плюсы: Клиент меньше нагружается, СЕО оптимизация, первоначальная загрузка быстрее
        Минусы: Нужны более мощные сервера`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "В чем разница HTTP и HTTPS?",
        answer: `HTTP(Hyper text transfer protocol). S – Secure(безопасность).
        HTTP – работает на 80 порту, HTTPS – на 443.
        Браузер считает что сайты HTTP опасны, туда трафик не пускают.
        HTTPS использует шифрование для защиты данных, передаваемых между клиентом и сервером. Это предотвращает перехват и изменение данных. Предотвращает атаку main-in-the-middle, когда человек стоит в центре между браузером и сервером и как-то перехватывает запросы и как-то обрабатывает.
        HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных. (TLS — это более современная и безопасная версия SSL)
        Как работает HTTPS: 
        1) Для использования HTTPS серверу нужен SSL/TLS сертификат, который подтверждает его подлинность. При создании сертификата сервер получает пару ключей. Публичный ключ доступен всем, а приватный ключ хранится в секрете на сервере. Сертификат содержит публичный ключ и информацию о сервере, подписанную доверенным центром сертификации (CA).
        2) Когда клиент (браузер) подключается к серверу, происходит процесс TLS Handshake: Клиент запрашивает сертификат у сервера, Сервер отправляет свой сертификат, содержащий публичный ключ, Клиент проверяет сертификат с помощью доверенного центра сертификации, Устанавливается защищенное соединение, используя обмен ключами и шифрование.
        Сертификаты выдаются доверенными центрами сертификации, которые проверяют подлинность и идентичность сервера перед выдачей сертификата.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи что такое TCP, content security policy(CSP)?",
        answer: `TCP (Transmission Control Protocol) - это сетевой протокол, который обеспечивает надежную и проверенную доставку данных между приложениями. 
        CSP - стандарт защиты сайтов от атак с внедрением контента. CSP описывает безопасные источники загрузки и блокирует ресурсы, которые не входят в «белый список». При настройки можно добавить в «белый список» источник.
        С помощью CSP, например, можно запретить встроенные скрипты. например есть текст эриа, куда злоумышленник может вставить код. Злоумышленник может написать код с вытягивание данные из куки.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи про SOLID, на примере React.",
        answer: `SOLID — это набор пяти принципов объектно-ориентированного программирования, которые помогают создавать более гибкий, поддерживаемый и расширяемый код.
                1) Принцип единственной ответственности (Single Responsibility Principle/разделения интерфейса) – Каждый компонент должен иметь одну единственную ответственность. В контексте React это означает, что компонент должен выполнять только одну задачу или функциональность. Например есть компонент туду листа, и компонент туду айтем, при этом вариант плодить все внутри APP, это против правила, код сложнее будет читать. 

                2) Принцип открытости/закрытости (Open/Closed Principle). В React компоненты должны быть открыты для расширения, но закрыты для модификации. Компонент должен иметь возможность добавлять новый функционал, не изменяя существующий код. У нас есть компонент Button, и мы хотим добавить новый стиль, не меняя исходный код. Мы создадим новый компонент с оберткой старого, а не будем добавлять новый функционал в старый код.
                3) Принцип подстановки Барбары Лисков (Liskov Substitution Principle). Объекты подклассов должны быть взаимозаменяемы с объектами суперклассов. В React это относится к возможности использовать компоненты или функции без необходимости менять код, который их использует. Если у нас есть компонент AnimalSound, который принимает любой компонент, реализующий интерфейс звука животного, мы можем заменить его любым другим компонентом, соответствующим интерфейсу.
                4) Принцип разделения интерфейса (Interface Segregation Principle). Клиенты не должны зависеть от интерфейсов, которые они не используют. В контексте React это может означать, что компоненты должны получать только необходимые им пропсы. Предположим, у нас есть компонент UserCard, который отображает информацию о пользователе. Но вместо передачи ему всех данных о пользователе, мы передаем только те данные, которые ему действительно нужны(name/email без остальных).
                5) Принцип инверсии зависимостей (Dependency Inversion Principle). Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. В React это означает, что компоненты должны зависеть от абстракций (например, через контекст или пропсы), а не от конкретных реализаций. Например, есть react компонент где выполняется запрос, а url прокидывается пропсы.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи про ООП. Полиморфизм, абстракция, наследование, инкапсуляция.",
        answer: `В ООП есть полиморфизм, абстракция, наследование и инкапсуляция.
        Полиморфизм – один и тот же метод, может работать по-разному. В React это может быть реализовано через компоненты, которые принимают разные пропсы или рендерят разные элементы в зависимости от контекста. (метод ToString() ).
        Инкапсуляция — приватные поля какие-нибудь в классе. скрытие внутренних деталей реализации компонента. В React это можно реализовать через локальное состояние и методы, которые не доступны извне компонента. Пример: компонент Counter, который инкапсулирует логику управления счетчиком внутри себя.
        Абстракция  — Это концепция, скрытия сложных деталей реализации и предоставление только необходимые свойства и методы. Например, Есть класс машина,  класс транспорт средство – слишком абстрактный классс. Когда мы будем наследоваться в классе машины от транспортного средства, то т/c будет абстракцией. Унаследуют методы и свойства.
        Наследование позволяет создавать новые классы, основанные на существующих, унаследовав их свойства и методы. В контексте React наследование встречается реже, так как чаще используются и функциональные компоненты. Однако наследование может быть полезным при создании классовых компонентов.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи алгоритм регистрации/авторизации/логина?",
        answer: `Когда мы нажимаем на кнопку отправить, на бэкэнд отправляется запрос, бекэнд валидирует полученные данные password и login, если все окей, то нам приходит заголовок Set Cookie и устанавливается куки в браузере. Там есть access и refresh токены(refresh используется для обновления акцесс токена). 
        Дальше есть интерцепторы в axios, есть в axios мидлварена, которая позволяет подписаться на resposonce и request и сделать какую-то работу. Например, если ошибка 401, с ошибкой авторизации, то тогда делаем запрос на бэк с рефреш токеном, чтобы обновить акцесс токен. И нам приходит новая пара токенов акцес и рефреш.
        Access токен нужен только для идентификации пользователя и передаётся в Cookie с флагом http only. 
        Может приходить только access токен(Используется для аутентификации. Обычно короткоживущий (например, 30 минут).
        (Если злоумышленник украдет акцес токен, то тогда он побудет недолгое время до обновления токена. А чтобы его обновить нужен акцес токен.)
        (Эти токены могут быть отправлены в HTTP-заголовке Set-Cookie или в теле ответа.)`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Interceptors (перехватчики)?",
        answer: `Interceptors (перехватчики) — это функция в axios, которая позволяет «перехватить» запросы или ответы до того, как они будут обработаны.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Где хранить токен?",
        answer: `Буду хранить в куки, там есть флаг http онли с помощью которого нельзя будет из JS достучаться до токена.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Что такое JSON Web Token (JWT) ?",
        answer: `JSON Web Token (JWT) — содержит три блока: заголовок(header), набор полей (payload) и сигнатуру. Отделяются точкой. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие).`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Nginx?",
        answer: `веб-сервера, на котором можно расположить статику фронта. Когда переходишь по домену, nginx обрабатывает запрос и выдает сбуилженный проект. NGinx снижает нагрузку на сервер, балансирует нагрузку, кеширует.`,
        categories: ["technology", 'platina1', "all"]
    },
    {
        question: "Расскажи про тесты",
        answer: `Были Юнит-тесты, которые проверяли функциональность отдельных частей, интеграционные, которые проверяли взаимодействие между ними, E2E тесты, которые имитировали действия пользователя, также использовались для тестирования взаимодействие с сервером, Снэпшот-тесты для тестирования внешнего вида приложения.
        1) unit-тесты (использовал React Testing Library, писал юнит-тесты для проверки отдельных функций и компонентов, таких как функции обработки данных, компоненты пользовательского интерфейса и кастомные хуки. Например: Тестирование валидаторов форм, проверка правильности рендеринга компонентов в зависимости от входных данных (props), тестирование логики кастомных хуков.)
        2) Snapshot Тесты(Jest(автоматически создает и сравнивает снэпшоты). Снэпшот-тесты помогали убедиться, что рендеринг компонентов не изменяется после внесения изменений в код. Например, Тестирование отображения UI-компонентов (кнопки, карточки, формы))
        3) E2E(Cypress(Сайпрес) Этот инструмент позволяет тестировать поведение приложения в браузере, имитируя действия пользователя) для взаимодействие с сервером и работу различных частей приложения вместе. Тестирование процесса прохождения курсов или завершения тестов на образовательной платформе.
        4) Интеграционные (использовал Jest и React Testing Library. для проверки взаимодействия нескольких компонентов и сервисов, чтобы убедиться, что они корректно работают вместе. Например, Тестирование работы формы с валидацией и отправкой данных на сервер, проверка взаимодействия компонентов с глобальным состоянием)`,
        categories: ["react", 'platina1', 'js', "all"]
    },
    {
        question: "Расскажи про оценку сложности алгоритмов",
        answer: `Есть оценки по времени и памяти алгоритмов. В основном используют временные оценки. Есть константное, логарифмическое, линейное, квадратичное.
            Допустим есть какой-то объект. Надо достать значение по свойству это будет за констаное время. В форичах сложность будет линейная. А например если есть цикл в цикле, то будет квадратичная.
            (Временная сложность показывает, как увеличивается время выполнения алгоритма по мере увеличения объема данных. Пространственная сложность (Space Complexity): Описывает, сколько памяти требует алгоритм во время своей работы, также в зависимости от размера входных данных.)`,
        categories: ["technology", 'platina1', 'js', "all"]
    },
    {
        question: "Расскажи про docker",
        answer: `Докер – Это ПО для автоматизации развертывания с использованием контейнеров. Контейнеры позволяют упаковать приложение вместе со всеми его зависимостями и окружением, что обеспечивает работу приложения на разных системах. С помощью Docker можно создать образ приложения. Например, для тестирования нового функционала бекэнд скидывает докер, я его быстро разворачиваю у себя. И можно тестировать локально.
        Плюсы:
        Переносимость: приложения в контейнерах могут быть легко перенесены с одной среды на другую, например, с локальной разработки на сервер в облаке.
        Экономия ресурсов: В отличие от виртуальных машин (VM), контейнеры используют меньше системных ресурсов
        Удобство откатиться к предыдущему состоянию. `,
        categories: ["technology", 'platina1', "all"]
    },
    {
        question: "Расскажи, что такое семантика в HTML и зачем она нужна.",
        answer: `Семантика в HTML — это использование HTML-тегов, которые явно описывают содержимое и структуру страницы. Семантические теги дают браузерам, поисковым системам и вспомогательным технологиям четкое представление о содержании и его значении на странице. С помощью семантики улучшается СЕО, улучшается доступность для людей с ограниченными возможностями, становится более понятный код. 
        Основные семантические теги в HTML:
        <header>: Задает шапку сайта или раздела.
        <nav>: Определяет навигационное меню.
        <section>: Представляет раздел страницы.
        <article>: Задает независимый и самодостаточный блок контента, например, статью.
        <aside>: Описывает содержимое, связанное с основным контентом, но не являющееся его частью, например, боковая панель.
        <footer>: Определяет нижний колонтитул страницы или раздела.
        <main>: Определяет основной контент страницы.
        <figure> и <figcaption>: Используются для добавления изображений с подписью.
        <time>: Определяет дату и время.
        С помощью семантики Скринридер зачитывает элементы на странице. Также для людей с ограниченными возможностями надо используется атрибуты Area.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи чем полезны даты атрибуты?",
        answer: `В дата атрибуты можно записывать различную информацию. Дата атрибуты ввели чтобы не пересекаться с нативными атрибутами html. Можно присваивать id. Это поможет когда пишем тесты, чтобы обращаться через айди. (data-test-id).
        (при проде есть бабел который удаляет их при сборке)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи про псевдоклассы, псевдоэлементы. В чем их преимущества?",
        answer: `Псевдоклассы (:) – это стилизация элементов в зависимости от их состояния или положения. Например, поменять стиль при наведении, фокусе, нажатии. Есть Active, Hover, focus, checked, nth-child first-child, last-child, not, 
        Псевдоэлементы (::) позволяют стилизовать определенные элемент, которые не присутствуют в html разметке. Они используются для добавления декоративных элементов или изменения частей содержимого без изменения HTML. Это Before(до), after (контент до и после элемента),  placeholder(стилизует placeholder), first-line(первая строка текста внутри элемента), first-letter(первая буква), selection(стилизует выделенный текст)
        псевдоэлемент – как будто реальный элемент, а псевдоклассы просто меняет стили при действии.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи вес селекторов по порядку.",
        answer: `инлайн стили(1000), айди(100), классы/псевдоклассы, атрибуты(10), тег/псевдоэлемент(1)
        important(1000) – перекрывает все.(с классом прибавляется)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Как можно выровнять блок по центру",
        answer: `1) С помощью flexbox(display:flex, justify-content: center, aling-items: center)
                 2) С помощью grid( display: grid, place-items: center)
                 3) По горизонтально с помощью margin: 0 auto
                 4) Через абсолютное позиционирование(position: absolute, left: 50%, top: 50%, transform: translate(-50%, -50%)
                 5) Текстовой блок с помощью (text-aling: center)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Как добавить отступ слева и справа?",
        answer: `1) margin: 0 10px;
                 2) через border прозрачный с box-sizing: border-box
                 3) margin-left, margin-right
                 4) margin-inline: 10px (margin-block(по вертикале)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи про производительность css анимаций.",
        answer: `1) Для анимаций лучше использовать такие свойства, как transform: translate (а не left) и opacity, (а не display:none), они выносится в отдельный слой, и в отдельном слое анимация происходит плавно, не вызывая перерисовки, не вызывая этап layout. они обрабатываются на уровне GPU, а не CPU(процессор). Нужно избегать дорогих анимаций, которые вызывают этап layout, изменение размеров, отступов, top, left, поскольку требуют они пересчёта всей компоновки и перерисовки.
        2) Минимизировать количество одновременных анимаций.
        3) Использовать will-change, который позволяет заранее сообщить браузеру, какие свойства будут изменяться. Это помогает браузеру оптимизировать обработку и задействовать GPU для этих изменений. (злоупотребление этим свойством может привести к лишнему использованию памяти, поэтому использовать его нужно осторожно и только для тех элементов, которые действительно будут анимироваться)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Grid vs Flex",
        answer: `Flex – представляет собой контейнер. Он одномерен, есть главная ось и побочная ось(колонки, строки). Grid представляет собой сетку, он двумерен.
Грид применяется обычно для общего макета, где были футер, маин, хедер. А флекс для отдельных компонентов.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "CSS спрайты",
        answer: `Способ объединить несколько изображений в одно. Затем с помощью CSS выбираются определенные области для отображения отдельных изображений. Это снижает нагрузку на сервер(то что один запрос идет, а не несколько).
        Чтобы показать определенное изображение из спрайта, используется свойство background-image для установки спрайта фоном элемента, а свойства background-position для выбора нужного изображения, смещая фон.
        Недостатки: большой размер изображения, что может замедлить начальную загрузку, сложность с позиционированием`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Rem vs em",
        answer: `Em: определяется относительно размера родительского элемента. Если элементу задано значение font-size: 2em, то размер шрифта будет в два раза больше размера шрифта родителя. Em может накапливаться, то есть если внутри элемента, который уже использует em, есть другой элемент, его значение будет умножаться на значение родителя 
        Rem: определяется относительно документа(html), независимо от родительских элементов. Если элементу задано значение font-size: 2rem, это означает, что размер шрифта будет в два раза больше размера шрифта корневого элемента. 
        (rem не накапливается, в отличие от em. Он всегда основывается на размере шрифта корня)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Огромная вложенность селекторов это хорошо?",
        answer: `Нет, это усложнение кода. Если мы захотим изменить придется менять везде, также могут возникнуть проблемы из-за специфичность селектов`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Container query + has. У меня есть UIKit компонент (карточка товара), я дальше использую его в отдельном фронте, есть сайдбар вывожу список самых популярных товаров, есть мэйн часть в которой вывожу список товаров. В мэйн части карточка по-другому выглядит имеет больший размер, масштаб другой. А в сайдабре маленькая карточка (короткое описание, меньше размеры, изображение). Что делать чтобы карточка могла иметь разное представление?",
        answer: `Нужно, когда используем карточку в сайдбаре дополнительно навесить класс, чтобы верстку правильно разместить через css, написать стилизацию . В мейн части тоже прокинуть новую верстку.

        (Про нововведения:
        В новом css вышли контейнер кверис. Это возможность вместо медиа запроса, написать контейнер запрос. Там в зависимости от ширины родительского контейнера написать свои стили. То есть под каждую ширину будут свои стили.
        Из обновления CSS это Введение в обычный CSS - CSS nesting – вложенность стилей(как в SCSS).
        Также Новый Псевдокласс Has – позволяет применить стили к элементу на основе наличия определенных дочерних элементов или других условий.)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи про последнее место работы",
        answer: `Сейчас я работаю в компании, которая занимается разработкой решений для корпоративного сектора. Это заказная разработка, разработка мобильных приложений и сайтов. 
        Лично я занимался разработкой образовательной платформы для корпоративного обучения и повышения квалификации. 
        С помощью этой платформы можно уменьшить время обучения новых сотрудников, отслеживать процесс обучения, проводить тесты для сотрудников. Платформа повышает уровень знаний персонала и способствует их росту и увеличению производительности, что позволяет сэкономить ресурсы компании. 
        На фронте есть дашборды, графики, каталог курсов, сами курсы, конструктор курса,  личный кабинет, разные элементы типа фильтров, модалок, селектов и таблиц. 
        Я работал в команде из 4 фронтенд-разработчиков, тимлида, 2 бэкендера, 2 дизайнера, 1 продуктолог, 2 тестировщика, аналитик. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Дейлики каждый день в начале дня. Релизы делал тимлид.деплой в докере.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Какая была команда на последнем месте работы",
        answer: `Я работал в команде из 4 фронтенд-разработчиков, тимлида, 2 бэкендера, 2 дизайнера, 1 продуктолог, 2 тестировщика, аналитик. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Дейлики каждый день в начале дня. Релизы делал тимлид.деплой в докере.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Какой был стек технологий на последнем месте работы",
        answer: `TypeScript, React, MobX-State-Tree, SCSS, React Router Dom, Headless UI, Gitlab, Axios, Webpack, ESlint, Prettier, React Hook Form.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Сколько человек в комании?",
        answer: `Около 50 челоек. 10 фронтов. Компания тянет одновременно около 3-5 проектов`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Где использовалась многошаговая форма",
        answer: `Многошаговая форма использовалась для создания и настройки нового курса. Такой процесс часто требует ввода большого количества информации, и разбивка его на несколько этапов улучшило пользовательский опыт. Этапы:
        Основная информация: Название курса, краткое описание, категория, уровень сложности.
        Настройка контента: Загрузка учебных материалов, добавление модулей и тем, порядок прохождения.
        Настройка доступа: Выбор групп, которые будут иметь доступ к курсу, настройка прав доступа и сроков прохождения.
        Настройка тестов: Добавление тестов, настройка вопросов, количество попыток, вес оценок.
        Предварительный просмотр и подтверждение: Проверка всех введенных данных перед сохранением курса.
        На каждом шаге отправлялся запрос на бэк для сохранения заполнения данных.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Какие у тебя были инетресные задачи",
        answer: ` Если говорить про интересные задачи, которые делал 
        В целом, было интересно разрабатывать проект образовательной платформы, где было много логики, много созвонов с разными членами команды в том числе с беками, чтобы обсуждать контракты. Была работа с uikitом, хорошо выстроенные процессы в команде. 
        Из технических задач занимался разработкой сложной MultiSteps формой, которая позволяла работать абсолютно с любой формой в приложении. До этого у нас в некоторых местах был копипаст, код разрастался.  Было принято решение на ретро завести задачу на создание новой функциональной формы. Я приступил с нуля заниматься ей. Успешно закончил, тем самым сделал одну отправную точку в коде форм. В общем задача была достаточно интересная. 
        Также встала необходимость использовать селекты для фильтров. После добавления селекта в uikit увидел, что при тестирования на реальных данных, лагает селект из-за большого количества элементов. Я предложил лиду внедрять виртуализацию, завели задачу. После внедрения действительно было облегчение, потому что не отрисовывалось большое количество дом нод, поэтому повысилась производительность т.к. этап layout подсчёта размеров и позиции элементов на странице очень дорогой.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Расскажи про первое место работы",
        answer: `До этого я работал в компании Exore, которая занимается заказной разработкой программного обеспечения, преимущественно в области веб-приложений. Я занимался разработкой платформы для клиентской поддержки и работы агентов. Эта платформа была разработана для внешней компании для внутреннего использования и предоставляет инструменты для анализа и отчетности, помогая понять, насколько эффективно работают службы поддержки, какие запросы наиболее частые, и как можно улучшить качество обслуживания. Также платформа упрощает процесс управления тикетами и взаимодействие с клиентами, что способствует повышению производительности и удовлетворенности клиентов.
        На фронте реализованы: дашборды, личный кабинет, статистики ответов, управление тикетами, шаблоны ответов, разные элементы типа фильтров, модалки, таблицы
        Я работал в команде, состоящей из 2 бэкенд-разработчиков, 3 фронтенд-разработчиков, проектного менеджера, дизайнера, аналитика и 2 тестировщиков. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Релизы тимлид делал, деплой в докере.

        ↪️ Если говорить про интересные задачи, которые делал 
        Одной из самых интересных задач для меня было создание интерфейса для управления тикетами, который отображал, сортировал и фильтровал данные в реальном времен. Я впервые в коммерческом проекте работал с WebSocket. До этого я не имел опыта использования этой технологии в реальных проектах, поэтому я с удовольствием взял эту задачу. Работа с WebSocket оказалась интересной, так как позволила мне глубже погрузиться в технологии реального времени, что значительно отличалось от моего предыдущего опыта.
        Еще одной из интересных задач было внедрение выбора цветовой схемы интерфейса (тёмная и светлая темы). Я разработал ThemeProvider и кастомный хук useTheme, используя CSS переменные (var). Это позволило пользователям настраивать интерфейс под свои предпочтения и улучшило общее восприятие

        Была интересная задача с подгрузкой данных при скроле. Для реализации Infinity Scroll я использовал Intersection Observer API, который позволил отслеживать появление элементов на экране и динамически загружать новые данные по мере прокрутки страницы. Это решение повысило производительность, так как данные подгружались только мере необходимости. Также этот функционал я добавил UI Kit. Этой реализацией я не только получил опыт работы с Infinity scroll и interection observer, но и улучшил производительность приложения. `,
        categories: ["behavioral", "all"]
    },
    {
        question: "Что такое TypeScript? Зачем он нужен?",
        answer: `TS - это языковая надстройка над JavaScript. TS компилируется в чистый JavaScript и полностью совместим с ним. Он добавляет статическую типизацию. Типы переменных и функций проверяются на этапе компиляции, что улучшает предсказуемость кода. TS Помогает избегать ошибки. Имеет самодокументацию(описывает в объектах какие есть свойства). С помощью TS учшается безопасность кода. Также поддерживает современные возможности ECMAScript. Благодаря явной типизации редакторы могут предоставлять точные подсказки и автодополнение. Например, TS нам сильно поможет понять код, который был давно написан. поможет разобраться в написанном компоненте, вспомнить пропсы и каких они типов. Без TypeScript почти невозможно существование в больших проектах.`,
        categories: ["ts", "all"]
    },
    {
        question: "Отличие Unknown от Any?",
        answer: `any — это тип, который отключает все проверки типизации. Переменные any 
        могут принимать любые значения, и любые операции с ними разрешены. Использование any убирает смысл использования TypeScript. Ошибки проявляются только на этапе выполнения программы.
        unknown — это неизвестный тип, который, как и any, может хранить значения любого типа, но с одним ключевым отличием: мы не сможем выполнять какие-либо операции с переменной типа unknown, пока явно не проверим её тип. Это делает unknown безопасным аналогом any.

        unknown, используется когда нужно работать с переменными, которые могут быть любого типа, но при этом мы хотим обеспечить безопасность и строгость типизации. Например, это может быть полезно в функциях, которые принимают значения от пользователя, API или сторонних библиотек, где нужно тщательно проверять типы перед использованием. Any обычно используется временно  при миграции проекта, во всяких точечных моментах.`,
        categories: ["ts", "all"]
    },
    {
        question: "TypeGuard как реализовать",
        answer: `1) проверка типов(typeof)
        2) if 
        3) Проверить если ли свойство (‘svoistvo’ in obj).
        4)const isSomeObj = (obj: Value): entity is SomeObj => “key” in entity`,
        categories: ["ts", "all"]
    },
    {
        question: "Транспиляция что такое?",
        answer: `Транспиляция - процесс преобразования одной сущности в другую(из TS в JS).`,
        categories: ["ts", "all"]
    },
    {
        question: "Как достать ключи из объекта",
        answer: `keyof Obj`,
        categories: ["ts", "all"]
    },
    {
        question: "Разница между Type и Interface",
        answer: `interface можно расширять с помощью ключевого слова extends, позволяя создавать наследуемые типы.
\n type поддерживает объединение (intersection) и пересечения(union), что позволяет комбинировать несколько типов.
\n interface поддерживает возможность слияния. Если два интерфейса с одним именем объявлены в разных местах, они объединяются в один интерфейс. type не поддерживает слияние. Будет ошибка.
\n interface может описывать только объекты, классы и функции, а type может и примитивные значения`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Omit?",
        answer: `Omit исключает указанные свойства из типа, оставляя остальные`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Pick?",
        answer: `Pick выбирает определённые свойства из объекта и создает новый тип с только этими свойствами.`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Extract",
        answer: `Extract выбирает типы, которые совместимы с переданным типом(то есть которые перескаются)`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Exclude?",
        answer: `Exclude удаляет типы, которые совместимы с переданным типом (то что не входит в объединение).`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Partial и Required?",
        answer: `Partial - длеает ключи необязательным, а Required - обязательно`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Record?",
        answer: `Record<string, string | number> - создается тип объекта с фиксированными ключами и значениями определённого типа. первым указываются типы ключей, вторым типы значений.`,
        categories: ["ts", "all"]
    },
    {
        question: "void vs never",
        answer: `void — это тип, указывающий на то, что функция ничего не возвращает, но она может завершиться успешно (например, выполнит свою логику и вернёт undefined).
never — это тип для функций, которые никогда не завершатся нормально, либо из-за выброса ошибки, либо из-за бесконечного выполнения (например, бесконечный цикл)`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое Enum?",
        answer: `В TypeScript enum (перечисление) — это специальный тип данных, который позволяет объявлять набор именованных констант`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое Awaited ?",
        answer: `Awaited — это условный тип, который извлекает тип значения из промиса или объекта, который может быть разрешённым промисом. Это полезно для работы с асинхронными операциями.`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое ReturnType?",
        answer: `ReturnType — это тип, который извлекает тип возвращаемого значения из функции. Это особенно полезно, когда вам нужно знать тип, который возвращает функция, но без явного указания этого типа.`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое Generics?",
        answer: `Generics — это способ описания функций или интерфейсов, которые могут работать с любым типом данных. Они позволяют писать код, который может принимать любые типы и при этом сохранять типовую безопасность.`,
        categories: ["ts", "all"]
    },
    {
        question: "Какие типы данных есть в JS?",
        answer: `Есть примитивные и объектные типы данных. Примитивных данных всего 7. Это string, number, boolean, null, undefined, symbol, bigInt . Объектные делятся на массивы, объекты, функции. Разница между примитивными и объектными заключается в том, что примитивные данные копируются по значению, а объектные по ссылке.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Как This работает в JS?",
        answer: `Значение this определяется контекстом вызова. this всегда указывает на объект, в контексте которого была вызвана функция. Он не привязывается к функции на этапе её объявления, а определяется в момент вызова.
В строгом режиме (strict mode) внутри функции this будет undefined. В нестрогом режиме оно будет ссылаться на глобальный объект.
В глобальной области, вне функций, this будет ссылаться на глобальный объект: в браузере это Window, а в Node.js это global.
Когда метод вызывается через объект, this указывает на сам объект.
This есть у Function Expression и Function Declaration.
Стрелочные функции не имеют собственного контекста this. Они используют this из внешнего контекста.
Когда вызывается конструктор через new, this указывает на создаваемый объект.
С помощью методов call, apply и bind можно явно установить значение this
call и apply вызывают функцию сразу и позволяют передать контекст. В apply передается массив элементов и контекст. В Call передается элементы через запятую и контекст.
bind возвращает новую функцию с установленным контекстом(в Function Expression или Function Declaration)
В обработчиках событий this указывает на элемент, к которому прикреплен обработчик.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Что такое контекст вызова?",
        answer: `контекст вызова - это объект, к которому привязана функция в момент вызова. This - это ссылка.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Расскажи что такое Class в JS?",
        answer: `класс — это синтаксический сахар над функциями-конструкторами и прототипным наследованием. Классы упрощают создание объектов и работу с наследованием, делая код более читаемым и структурированным.
Классы объявляются с помощью ключевого слова class. Внутри класса можно объявлять методы и конструкторы.
Метод constructor вызывается при создании нового класса и инициализирует объект.
Методы, объявленные внутри класса, автоматически добавляются в прототип объектов, создаваемых этим классом.
Классы могут наследовать друг от друга с помощью ключевого слова extends. Для переопределения и расширения функциональности используется метод super(). Родительский класс называется суперклассом.
Статические методы принадлежат самому классу, а не его экземплярам. Их можно вызывать напрямую через класс.
Классы могут содержать геттеры и сеттеры, которые позволяют управлять доступом к свойствам объекта.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Понятия как __proto__ и prototype",
        answer: `__proto__ — это свойство объекта, которое ссылается на прототип, с которого объект наследует свойства и методы. Является часть цепочки прототипов, по которой JS ищет свойство и методы объекта, если они не найдены в самом объекте. 
Использование Proto является устаревшей и не рекомендуемой практикой.
prototype — это свойство функции конструктора, которое определяет прототип для всех объектов, создаваемых этой функцией.  Когда создается новый объект через конструктор, этот объект получает в качестве своего прототипа значение prototype конструктора. То есть, этот объект будет унаследовать методы и свойства, определенные в prototype. Когда создается новый объект с помощью конструктора, этот объект получает свойство __proto__, которое указывает на prototype конструктора.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "В чем разница между методами класса и статическими методами?",
        answer: `Методы класса принадлежат экземплярам класса, а статические методы — самому классу и не могут быть вызваны через экземпляры.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Как работают геттеры и сеттеры?",
        answer: `Геттеры позволяют вычислять свойства при доступе, а сеттеры — управлять тем, как значения свойств присваиваются.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Что произойдёт, если не вызвать super() в наследуемом классе?",
        answer: `Будет ошибка, так как конструктор дочернего класса должен сначала вызвать конструктор родительского класса.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Разница var, let, const?",
        answer: `Разница между var, let, и const заключается в области видимости.
\nvar - Имеет функциональную область видимости. Если var объявлена внутри функции, она видима только в этой функции, но если объявлена вне функции, она становится глобальной. var не имеет блочной области видимости, то есть переменная, объявленная с помощью var внутри блока (например, в цикле for, if, и т.д.), видима за пределами этого блока. Может быть переобъявлена в той же области видимости без ошибок. Может быть объявлена и инициализирована позже. При отсутствии инициализации получает значение undefined.
\nlet и const - Имеют блочную область видимости (block-scoped). Переменные, объявленные с помощью let или const, видимы только в пределах блока, в котором они объявлены. Нельзя переобъявить. Не поднимаются до начала своего объявления. hoisting все равно происходит, но инициализация — нет. Переменную нужно объявить перед использованием, иначе возникнет ошибка ReferenceError. При объявлении через Const  примитивные типы данных нельзя изменить. Но у объектов и массивов можно изменять содержимое.
`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Что такое замыкание?",
        answer: `Замыкание - это комбинация функций и лексического окружения, в котором функция была создана. Например, Если мы внутри одной функции, объявляем другую функцию, то внутренняя функция запоминает внешние переменные и имеет к ним доступ.
Каждая функция по сути является замыканием в JS. Запоминание происходит за счет скрытого свойства Environment. Иными словами Замыкание - это способность функции запоминать лексическое окружение, в котором она была создана.
Применяется для эмуляции приватных переменных, для мемоизации, для создание фабричных функций.
\nЗамыкания может приводить к утечкам памяти, если их использовать неосторожно. Потому что при замыкание, переменные внешней функции сохраняются в памяти до тех пор, пока замыкание существует. `,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Что такое лексическое окружение?(Environment)",
        answer: `Это некоторый невидимый скрытый объект, который есть у блока, скрипта или функции. Он состоит из двух часть: объект с переменными которые доступны в текущей области видимости, вторая ссылка на внешние лексическое окружение.`,
        categories: ["platina2", 'js', "all"]
    },
    {
        question: "Расскажи про Event Loop",
        answer: `Event Loop - это такой событийный цикл, который позволяет организовать работу с синхронными и асинхронными операциями. Event Loop позволяет выполнять асинхронные задачи без блокировки основного потока выполнения, несмотря на то, что JavaScript является однопоточным языком. Event Loop — это не часть самого JavaScript, а часть окружения, в котором JavaScript выполняется, например, браузера или NodeJS.
Сначала выполняется весь синхронный код. Когда встречается асинхронная операция (например, setTimeout, запрос на сервер), она передается в Web API, который работает в фоне и передает задачи в очередь. Затем выполняются все микротаски. Затем выполняется одна макротаска. Если макротаска плодит еще микротаски. То тогда будут выполняться все микротаски, а потом уже еще одна макротаска. Есть стек и очередь вызовов, очередь микротасок и макротасок и WebApi.
Микротаски - promise, mutation observer, queue microtask
Макротаски - SetTimeout, setInterval, Запросы на сервер,события(клик, загрузка изображений), файловые операции
\n Представим есть какой-то console.log, который в свою очередь добавится в стек вызовов, затем ниже в коде есть вызов функции. И эта функция вызывается, и внутри нее еще был вызов функции. Постепенно стек пополняется, синхронщина выполняется. И стек очищается, очистка стека называется одним тиком(one tick). А конец стека называется next tick. В nodeJS перед следующим тиком мы можем выполнить какую-нибудь логику(process.nextTick()). 
\n Дополнительно:
Движок JS Решает задачи с кучей и стеком вызов, работа с памятью(выделение и сбор мусора), Компиляция в машинный код, оптимизация`,
        categories: ["platina2", 'js', 'react', "all"]
    },
    {
        question: "Что такое WebSocket, Pollings, SSE, long pooling",
        answer: `WebSocket - это протокол связи поверх TCP соединения, используется двухстороннее соединение, устанавливает постоянное соединение. Часто используется в чатах. Соединение устанавливается один раз. С помощью WebSocket может как клиент отправлять данные, так и сервер. Есть популярный Socket.IO, а есть просто нативный WebSocket(wss://url).
\n До вебсокетов использовали лонгпулинг. Клиент делает запрос на сервер и дожидается ответа от сервера, сервер держит этот запрос пока не появились новые данные. Как только сервер ответил обрабатыватся ответ и опять отправляется запрос и переходит в ожидание.
\n SSE - это когда только сервер может присылать события, когда какие-то данные обновились. Клиент не инициирует запросы после первого подключения, сервер сам передает обновления.
\n Pooling - это когда клиент отправлять запросы серверу для проверки обновления данных в определенном интервале.`,
        categories: ["platina2", "all"]
    },
    {
        question: "Что такое React",
        answer: `React - это библиотека, для создания пользовательских интерфейсов или Single page Application. Если сравнивать с JS, то в JS императивный подход. То есть мы как разработчики заботимся о том, как доставить дом ноды созданные нами, функционал, логику до пользователя на странице. Допустим есть какой-то список туду лист. Нам нужно при добавлении таски вызвать функцию CreateTask, там создать таску, будет какой-то Document.CreateElement, зааппендить новый текст. Это императивный подход, а декларативный подход как раз в React. Создаем setState и компонент начинает перерендер, и дальше реакт сам заботится о том как доставить изменения в настоящий дом. У реакта есть такое понятие как Virtual Dom. 
Virtual Dom - представляет упрощенную версию настоящего DOM. При SetState происходит перерендер, реакт строит Virtual Dom сравнивает его с предыдущим, этот этап называется reconciliation. Таким образом если в рамках сетстейта мы внесли 5 изменений в разных компонентах, реакт построил новый Virtual Dom и произошел Reconciliation, и пометил элементы которые нужно обновить и за одно обновление он вносит изменения в настоящий дом. А в JS будет 5 раз перерисовка, а layout очень дорогой этап. В этом огромный плюс Reactа. 
Также из плюсов реакта это компоненты подход, то есть мы можем переиспользовать компоненты многоразово, изолируя определенную логику,  синтаксис JSX, который позволяет писать HTML код в JS. Также React это самая популярная библиотека и она имеет большое сообщество. React хорошо интегрируется с инструментами для управления состоянием, такие как Redux, MobX, Context API.
Из минусов это React - не такой реактивный как Vue.
По поводу ключей в React. Key - это пропс, который используется для идентификации элементов при рендеринге списка. При обновлении списка React сравнивает ключи старого и нового списка. Если ключ не изменился, React оставляет элемент на месте, а если ключ изменился — пересоздаёт элемент.
Реакт используется эвристический алгоритм сложностью O(n), основываясь на двух предположениях: Два элемента разных типов приводят к построению разных деревьев(если тип ноды изменился, то нужно перестроить дерево заново), Разработчик может обеспечить стабильность элементов между рендерингами посредством пропа key .`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Virtual Dom",
        answer: `Virtual Dom - это отдельное дерево которое строится реактом. Реакт проходит рекурсивно по компонентам и строит по ним новое дерево. Когда компонент перерендеривается, он строит новое дерево и смотрит что изменилось, и меняет в дереве только то место которое поменялось. `,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Когда перерендывается компонент?",
        answer: `Изменился State, перендерился родительский компонент, изменились Props, в классовых компонентах ForceUpdate, если используется контекст, то при изменении его, при использовать userReducer реактовский.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Как минимизировать перерендеры?",
        answer: `\n Использовать React.memo. Он предотвращает перерендеры, если пропсы не изменились.
\n Использовать useMemo и useCallback: Мемоизация функций и вычислений предотвращает их пересоздание при каждом рендере.
\n Правильно использовать ключи при рендеринге списков. (помогает React правильно идентифицировать и обновлять элементы.)`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про правила хуков",
        answer: `Хуки можно создавать только в функциональных компонентах. Можно использовать в кастомных хуках. Нельзя вызывать в блоках, внутри условий, циклов или вложенных функций. Пользовательские хуки — начинающиеся с use. (Пользовательские хуки позволяют инкапсулировать логику состояния и эффектов, которая может быть повторно использована в разных компонентах) \n Дополнительно: в react 19 можно внутри if использовать хук Use(Туда прокидывается контекст).`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое SPA?",
        answer: `Single Page Application - это когда приложение загружается как одна страница приходит одна htmlка и динамически обновляет содержимое этой страницы, не перезагружая весь сайт. Это отличается от традиционных многостраничных приложений, где каждый переход между страницами сопровождается полной перезагрузкой страницы с сервера. Изменение контента страницы происходит через манипуляции с DOM. Это делает переходы между различными частями приложения плавными и быстрыми. Из плюсов: быстрая работа, Меньшая нагрузка на сервер. Из минусов: SEO-проблемы, Начальная загрузка может быть дольше.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Как вызвать перерендер?",
        answer: `С помощью This.ForceUpdate() - в классвовом компоненте. А в функциональном создать хук useForceUpdate, в нем будет написано return useCallback(()=> setCount(prev => prev+1)) `,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Какие есть хуки?",
        answer: `1) useState - для создания стейта
\n 2) useEffect - для реализации побочных эффектов и жизненных циклов компонента. По умолчанию useEffect выполняется после каждого рендера. Пустой массив будет означать что выполняется только при монтировании. Если в массив есть какое-то значение, то он будет выполнять при обновлении этого значения. Если return, то это будет отписка/очистка эффекта при размонтировании.
\n 3) useRef - Возвращает изменяемый объект, который сохраняет своё значение между рендерами. Полезен для сохранения ссылки на DOM-элемент или сохранения любых других изменяемых данных, которые не требуют повторного рендера.
\n 4) useMemo - Позволяет кешировать значение, чтобы не пересчитывать его на каждом рендере, если зависимости не изменились.
\n 5) useCallback - Возвращает мемоизированную версию функции, которая сохраняется между рендерами, если не изменились зависимости. ( вместе с HOC memo)
\n 6) useContext - Позволяет получить доступ к значению контекста. (Упрощает работу с React Context API, убирая необходимость использовать компонент-обертку Consumer)
\n 7) useLayoutEffect - Похож на useEffect, но запускается синхронно после всех изменений DOM и перед рендером браузера. Используется, когда нужно измерить или изменить DOM сразу после изменений и перед тем, как он отобразится на экране.
\n 8) useReducer - Позволяет управлять состоянием с помощью редюсеров (как в Redux). Полезен, когда логика обновления состояния становится сложной или когда необходимо управлять несколькими связанными значениями состояния.
\n 9) useTransition - Позволяет разделить обновления на срочные и отложенные, чтобы React мог обрабатывать обновления интерфейса плавнее. Удобен для обработки долгих или тяжёлых вычислений без блокировки пользовательского интерфейса.
 \n 10) useId - Генерирует уникальный id для элементов, например, для связки label и input. Полезен, когда необходимо гарантированно уникальные ID в пределах одного экземпляра приложения.
 \n 11) useDeferredValue - Позволяет откладывать обновление состояния до следующего рендера, чтобы избежать слишком частых обновлений. Полезен для оптимизации производительности при больших объёмах вычислений.
 \n 12) useImperativeHandle - Используется чтобы прокинуть вверх в вышестоящий родительский компонент.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "React Class vs React Component?",
        answer: `Реакт перешел к функциональным компонентам, потому что есть определенные минусы:
В классовых это this, bind, привязка контекста, обертка, которую ты видишь в dev тулзах над компонентами, сложнее дебажить, сложнее разрабатывать, один стейт.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Props drilling, Redux, Context?",
        answer: `Props drilling - это прокидывание пропсов в глубоко вложенному компоненту через несколько дочерних компонентов, которые могут даже не использовать эти пропы.
Для упрощения этого процесса создали инструменты для управлением состоянием приложения(Context, Redux, MobX) 
\n Context - Мы можем написать контекст, обернуть родительский компонент и после использовать в глубоко вложенном компонент данные из контекста.
\n Redux - есть отдельный стор, где хранятся переменные приложения. Данные изменяются через экшины, которые описывают что должно измениться, Для обновления состояния используются редюсеры — это чистые функции, которые принимают текущее состояние и экшины, и возвращают новое состояние.

\n Context VS Redux
Redux Хорошо подходит для крупных приложений с большим количеством состояний, где необходимо глобальное состояние. Context обычно используется для локального состояния (например, настройка темы, язык интерфейса). В контексте когда изменилось значение, то во всех компонентах где используется UseContext будет перерендер. `,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про Function Expression от Function Declaration и стрелочных функции.",
        answer: `Function Declaration - это стандартный способ объявления функций в JavaScript. Обычная функция, определенная с использованием ключевого слова function. Она доступна во всем объеме кода благодаря hoisting (поднятию). Это значит, что можно вызвать функцию до ее определения. Имеет собственный this. Есть псеводомассив arguments.
    \n Function Expression - Функция, присвоенная переменной. Она не поднимается (hoisting не применяется), поэтому вызвать функцию до ее объявления невозможно. Имеет собственный контекст this. Есть псеводомассив arguments.
    \n Arrow Function(Стрелочная функция) - Функции со специальным сокращенным синтаксисом. Есть неявный return. Не имеет собственного контекста this, оно наследуется из окружающей области видимости. Не поднимается (hoisting не применяется). Не может быть вызвана с new (не поддерживает конструкторские функции). Нельзя использовать arguments внутри стрелочной функции (оно также наследуется из внешней области).

    \n Различия: Стрелочные функции не имеют собственного контекста. Function Declaration поднимаются, Function Expression и стрелочные функции — нет. У стрелочных функций нет псевдомассива аргументов. К Function Declaration и Function Expression можно применять call, apply, bind.
    \n Anonymous Function (Анонимная функция) - Это функции без имени, часто используется в качестве колбэка. Не поднимаются. Не имеет имени, поэтому может быть вызвана только через переменную или передана как аргумент.
    \n IIFE (Immediately Invoked Function Expression)  - Функция, которая вызывается сразу же после объявления. Часто используется для создания локальной области видимости. Заключается в круглые скобки, чтобы интерпретатор распознал это как выражение.
    \n Constructor Function (Функция конструтор) - Функция, которая используется с ключевым словом new для создания объектов. Имеет собственный контекст this, который ссылается на новый созданный объект. Может использоваться для создания экземпляров объектов.
    \n Generator Function (Генератор) - Функция, которая может приостанавливать и возобновлять свое выполнение. Использует function* синтаксис и yield для пауз и возобновления выполнения.

    \n Async Function (Асинхронная функция) - Функция, которая возвращает промис (promise) и использует async/await для упрощения работы с асинхронными операциями. Особенности: Асинхронная функция всегда возвращает промис. Можно использовать await для ожидания завершения промиса.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Разница  между var, let. const?",
        answer: `Разница между var, let, и const заключается в области видимости.
\n var - Имеет функциональную область видимости. Если var объявлена внутри функции, она видима только в этой функции, но если объявлена вне функции, она становится глобальной. var не имеет блочной области видимости, то есть переменная, объявленная с помощью var внутри блока (например, в цикле for, if, и т.д.), видима за пределами этого блока. Может быть переобъявлена в той же области видимости без ошибок. Может быть объявлена и инициализирована позже. При отсутствии инициализации получает значение undefined.
\n let и const - Имеют блочную область видимости (block-scoped). Переменные, объявленные с помощью let или const, видимы только в пределах блока, в котором они объявлены. Нельзя переобъявить. Не поднимаются до начала своего объявления. hoisting все равно происходит, но инициализация — нет. Переменную нужно объявить перед использованием, иначе возникнет ошибка ReferenceError. При объявлении через Const  примитивные типы данных нельзя изменить. Но у объектов и массивов можно изменять содержимое.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Разница  между == и ===",
        answer: `Нестрогое сравнение выполняет преобразование типов перед сравнением. Если типы разные пытается привести к одному. При строгом сравнении значения сравниваются по типу и самому значению. В большинстве случаев рекомендуется использовать строгое сравнение, чтобы избежать непредвиденных ошибок.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое всплытие событий?",
        answer: `Всплытие событий (Event Bubbling) - Это когда событие происходит на элементе, оно сначала обрабатывается самим этим элементом, а затем последовательно передается его родительским элементам, поднимаясь по иерархии DOM-дерева вплоть до document.
\n Всплытие можно предотвратить, внутри коллбека которым обрабатывается элемент, написать  event.stopPropagation().
\n Этапы обработки событий: Событие в браузере проходит три основных этапа:
\n Фаза захвата (Capture phase): Событие идет сверху вниз по дереву DOM к целевому элементу. На этом этапе по умолчанию обработчики не срабатывают, но можно принудительно сделать так, чтобы они срабатывали на этапе захвата, передав третий параметр в методе addEventListener как true.element.addEventListener('click', handler, true);
\n Фаза цели (Target phase): Событие доходит до целевого элемента, на котором произошло событие. Обработчики событий этого элемента срабатывают.
\n Фаза всплытия (Bubbling phase): Событие поднимается обратно вверх по дереву DOM, срабатывая на всех родительских элементах до document.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "В чем разница null, undefined, Undeclared",
        answer: `undefined - это значение переменной, которая объявлена, но не инициализирована. Также, функция, которая не возвращает значение, автоматически возвращает undefined. Если к объекту или массиву обращаются по несуществующему ключу или индексу, это также даст undefined.
\n null - это значение, которое явно присваивают, чтобы указать на отсутствие значения.

\n Undeclared. Это состояние переменной, которая не была объявлена с помощью ключевых слов var, let или const. Если ‘use strict’ не включен, то можно писать a = 10, b =10, без использования let,cont,var. это есть синтаксис declared. И переменные добавляются в объект window. К ним потом можно обратиться Window.a window.b. А Если будет включен строгий режим, то будет ошибка.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Из-за чего происходит полное зависание страниц?",
        answer: `1) С Бесконечным цикл While(True) основной поток будет заблокирован, бесконечная рекурсия, Стек будет переполнен и страница зависнет
\n 2) Можем забить стек Microtaskами. создать функцию которая вызывает промис самого себя же. Очередь микротасков будет выполняться до того момента пока они не закончатся
\n 3) Если используются promt(диалоговое окошко, с инпутом куда можно ввести значение), alert(с сообщением), confirm. То есть пока они вызваны, страница будет заблокирована`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Функция высшего порядка(HOF-Higher-Order Function), Высший компонент(HOC-Higher-Order Component)",
        answer: `HOF — это функция, которая либо принимает в качестве аргументов другие функции, либо возвращает функцию как результат. Примеры функций высшего порядка это методы массивов: map, filter, reduce
\nHOC — Это функция, которая принимает компонент и возвращает новый компонент, расширяя его функционал.
HOC применяется для решения таких задач, как: Обёртка для авторизации (проверка прав пользователя), Логика кэширования данных, Управление состоянием, например, добавление общих данных из контекста.
Различия:
\n HOC сосредоточен на компонентах, а HOF — на работе с функциями в общем контексте.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Как перебрать объект?",
        answer: `Перебрать объект можно с помощью for...in, Object.keys(), Object.values(), Object.entries() или Object.getOwnPropertyNames().
    \n цикл for...in используется для перебора всех перечисляемых свойств объекта. Это включает свойства объекта, а также те, которые могут быть унаследованы от прототипы. Лучше проверять наличие свойства с помощью hasOwnProperty, чтобы избежать перебора свойств из прототипа.
    \n Метод Object.keys() возвращает массив всех собственных ключей объекта. Этот метод можно использовать вместе с forEach для перебора.
    \n Метод Object.values() возвращает массив значений объекта, и его также можно перебирать.
    \n Метод Object.entries() возвращает массив пар [ключ, значение]. Этот метод удобен для перебора как ключей, так и значений одновременно.(можно переберить через for of)
    \n Object.getOwnPropertyNames(). Этот метод возвращает массив всех собственных свойств объекта.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "В чем разница между Spread и Rest?",
        answer: `Spread оператор распаковывает элементы, его можно использовать для поверхностного клонирования. Rest используется для функций с произвольным количеством аргументов. Spread расширяет существующие структуры данных, а Rest собирает их в новый массив или объект. Другими словами: Spread — чтобы распаковать элементы. Rest — чтобы упаковать элементы.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Сравнение Объектов",
        answer: `При сравнение двух объектов будет False, так как объекты сравниваются по ссылкам. У двух разных объектов будут разные ссылки.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Объектная обертка?",
        answer: `Объектная обертка (wrapper object) — это механизм, с помощью которого примитивные значения, такие как строки, числа и логические значения, временно преобразуются в объекты для того, чтобы позволить доступ к их методам. Примитивные типы данных не имеют методов и свойств, но благодаря объектным оберткам мы можем использовать такие методы, как, например, toUpperCase() или toFixed().`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про коллекции в JS",
        answer: `Map — это коллекция для хранения пар "ключ-значение". Map позволяет использовать любые типы данных в качестве ключей, сохраняет порядок вставки элементов, имеет методы set для добавления, get для получения, delete для удаления элементов и has проверки наличия ключей, size для подсчета элементов.
Отличие от объекта это то, что могут быть любые типы ключей, сохраняется порядок ключей (у объекта ключи все преобразуются к строке, и все сортируются по умолчанию), есть возможность получить длину через size(а у объекта нет). Есть foreach

\n Set — это коллекция, которая хранит уникальные значения. В отличие от массивов, Set автоматически убирает дублирующиеся элементы. Он может хранить как примитивные значения, так и объекты. Set сохраняет порядок добавления элементов. Имеет методы add для добавления, delete  для удаления и has для проверки наличия элемента. size для подсчета элементов.

\n Дополнительно:
\n WeakSet и WeakMap структуры данных созданы для хранения актуальных данных. Пока есть ссылка на ключ мы можем получать значение из коллекций. Как только она пропадет произойдет удаление.
WeakSet - хранит только объекты, элементы могут быть удалены сборщиком мусора, не поддерживает методы для перебора элементов, таких как forEach, поскольку элементы могут быть удалены в любой момент.
\n WeakMap похож на Map, но с одной важной особенностью: ключи в WeakMap должны быть объектами, а не примитивами. Не поддерживает методы для перебора элементов, таких как forEach, поскольку элементы могут быть удалены в любой момент. Ключи в WeakMap могут быть удалены сборщиком мусора, если они больше не используются.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про Hoasting(поднятие)",
        answer: `Это когда мы можем вызвать функцию или переменную до ее объявления. Хостится  function declaration, var хотстится, но будет undefined, let const тоже хостятся, но будет ошибка так как они находятся во временной мертвой зоне.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Каррирование?",
        answer: `Каррирование - это процесс разбиения функции, которая принимает много аргументов, на цепочку функций которые принимают меньше аргументов и возвращают функции для обработки следующего аргумента, и только последняя функция возвращает значение. Используется для Переиспользования аргументов: Можно фиксировать некоторые аргументы и получать новые функции.(в Redux comose)`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Null === object будет false или true?",
        answer: `typeof null === object равно true из-за исторической ошибки в реализации языка.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Pure Component и class component в чем разница?",
        answer: `Class Component — это обычный класс, который расширяется от React.Component и использует метод render() для отображения UI. При каждом обновлении (даже если пропсы или состояние не изменились), такой компонент по умолчанию будет рендериться.
\n PureComponent — это оптимизированный класс компонента. Он работает так же, как обычный Component, но с одной ключевой особенностью: PureComponent реализует поверхностное сравнение (shallow comparison) пропсов и состояния в методе shouldComponentUpdat, на подобии memo HOCa. Это означает, что компонент рендерится только тогда, когда есть реальные изменения в его пропсах или состоянии.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что нельзя реализовать с помощью функционального, но можно с помощью классового компонента?",
        answer: `нельзя реализовать ErrorBoundary - Компоненты, которые отлавливают ошибки во время рендеринга, в методах жизненного цикла или в конструкторах дочерних компонентов. Для этого требуются методы жизненного цикла, такие как componentDidCatch и getDerivedStateFromError, которые доступны только в классовых компонентах.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Какие есть типы TS?",
        answer: `number, string, boolean, null, undefined, symbol, bigInt
any, unknown, never, void, литеральный тип(хардкор a = 1)
type, interface, generics, enums, extract, exclude, record, awaited, returnType, nulluble, omit, pick`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Когда происходит рендеринг?",
        answer: `- Когда компонент впервые монтируется.
\n - Когда изменяются пропсы компонента.
\n - Когда изменяется состояние компонента.
\n - Когда происходит перерендер родительского компонента (если дочерний не оптимизирован).`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое fiber?",
        answer: `Fiber — это внутренний механизм React, который появился в 16 версии для оптимизации рендеринга. Он позволяет разбивать рендеринг на небольшие задачи, что улучшает производительность за счет асинхронного выполнения, приоритизации задач и возможности приостановки или отмены долгих операций. Fiber помогает сделать интерфейс более отзывчивым, особенно в сложных приложениях.
\n Вот у нас есть реактовский компонент, который мы как разработчики видим. Видим этот код. По сути это DOM, в котором мы находимся. а Fiber это волокно это некий утеплитель который мы не видим. Но вообще можно увидеть написать Console.log этого компонента реактвского и увидь fiber Объект. В нем хранится последовательность вызова хуков, пропсы, верстка. Ну еще там другая информация есть, куча всего в этом объекте. В Fiber используется Symbol. В процессе рендеринга Fiber позволяет React обрабатывать дерево компонентов поэтапно и эффективно, сохраняя информацию о каждом шаге и о том, что было сделано.
`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "useEffect и useLayoutEffect в чем разница?",
        answer: `useLayoutEffect Выполняется синхронно после того, как изменения DOM завершены, но до того, как браузер отрендерит компонент. 
        \n useEffect: Выполняется асинхронно после того, как React закончит рендеринг и обновит DOM. Это позволяет браузеру сначала отобразить изменения на экране, а затем выполнить побочный эффект.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "render vs mounting в чем разница?",
        answer: `Mounting — это процесс добавления компонента в DOM, он происходит один раз за жизненный цикл компонента, когда компонент становится видимым на странице.
\n Render — это процесс создания виртуального DOM на основе состояния и пропсов компонента. Render может вызываться многократно, когда происходит изменение состояния, пропсов или родительского компонента.
\n Если надо состояние узнать смонитирован компонент или нет(const IsInnited = useRef(false); useEffect(()=> isInnited.current = true))`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про Web Workers, Service Workers",
        answer: `Web Workers - позволяет выполнять какие-то вычисления вне основного потока. Имеет свой Event Loop. При этом у web Workerа есть ограничения: Нет доступа к DOM нодам, вместо window там self используется,нет  доступа к кукам, local и sessionstorage, нет доступ к микрофоне, камере. Имеют доступ к объекту Navigator и могут использовать API для сетевых запросов. Накладываются ограничения по ресурсам от самого браузера. (количество воркеров которые можно создать зависит от браузера, около 512)

\n Service Workers - это прокси между веб-приложением и сетью. Они работают как фоновый процесс, управляя сетевыми запросами, кэшированием и возможностью работы в оффлайн-режиме. Обычно используется в PWA(Progressive Web Apps). С помощью нее можно делать пуш-уведомления.Они не имеют прямого доступа к DOM. Работают только через HTTPS соединению. Обмен данными между основным и фоном потоком происходит через Postmessage.
\n Когда использовать?
\n - Web Workers идеально подходят для выполнения сложных вычислительных задач, не блокируя интерфейс приложения.
\n - Service Workers полезны для управления сетевыми запросами, кэширования ресурсов и создания оффлайн-приложений`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про Сборку мусора(garbage, collector)",
        answer: `JavaScript использует автоматическое управление памятью. В основе этого процесса лежит концепция ссылок на объекты. Если объект не имеет больше ссылок на него или на него нельзя добраться через другие объекты, он считается "неиспользуемым" и может быть удален.
    \nНапример, у нас написан код let button = queryselector(‘.button’); - затем мы поработали с этой переменной, удалили из DOMа, но ссылка в переменной осталась, поэтому нужно переменной присвоить null. Тогда придет сборщик мусора и очистит.
\n Сборка мусора работает по следующим принципам:
\n - Новый код проверяется чаще, а старый реже.
\n - Во время простоя сборщик может что-то посмотреть
\n Сборка мусора выполняется по частям, что позволяет избежать "зависаний" приложения на время выполнения одной большой операции очистки.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Функции генераторы?",
        answer: `Функция генератор - это особый вид функций, которые позволяют приостанавливать и возобновлять выполнение. Функции-генераторы обозначаются с помощью символа * после function. Вместо return внутри генератора используется ключевое слово yield, которое приостанавливает выполнение функции и возвращает значение. Функции генератор возвращают итератор. С помощью которого можно итерироваться с помощью метода Next. Вызов next() возобновляет выполнение генератора с того места, где оно было приостановлено и выполняется до следующего yield. Next возвращает объект с двумя ключами: value (значение, которое вернул yield) и done (логическое значение, указывающее, завершен ли генератор). Удобны для работы с потоками данных или асинхронными задачами,  при работе с большими наборами данных!
\n Преимущества функций-генераторов:
\n - Генераторы создают значения "на лету", что особенно полезно при работе с большими наборами данных.
\n - Генераторы позволяют точно контролировать, когда и какие значения генерируются.
\n - Удобны для работы с потоками данных или асинхронными задачами.
\n (((Генераторы возвращают объект, который является итератором и итерируемым одновременно. Это позволяет использовать их в циклах for...of или напрямую вызывать метод next().)))`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое рекурсия?",
        answer: `Рекурсия - это функция, которая вызывает саму себя до тех пор, пока не выполнится условие выхода из этой рекусрии(например if).`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое Прокси?",
        answer: `Прокси— это объект, который позволяет перехватывать и изменять базовое поведение другого объекта. С помощью Proxy можно настраивать поведение операций, таких как чтение, запись, вызовы методов, перебор свойств и другие. Они полезны для создания гибких API, улучшения безопасности данных, кэширования и других оптимизаций в приложении. Чтобы создать прокси, используется конструктор Proxy, который принимает два аргумента:
\n 1) target — объект, для которого нужно создать прокси.
\n 2) handler — объект с методами, которые будут перехватывать операции, выполняемые на объекте.
\n (Можно использовать прокси для проверки типов данных или их форматов перед записью в объект. Прокси можно применять для автоматического логирования всех операций с объектом, чтобы отлаживать код или отслеживать его использование. Прокси может кэшировать вычисляемые значения и возвращать их при повторных запросах.)

\n Прокси может перехватывать различные операции через так называемые ловушки. Пример ловушек:
\n 1) get(target, property, receiver) — перехватывает чтение свойства.
\n 2) set(target, property, value, receiver) — перехватывает запись свойства.
\n 3) has(target, property) — перехватывает проверку существования свойства через in.
\n 4) deleteProperty(target, property) — перехватывает удаление свойства через delete.
\n 5) apply(target, thisArg, argsList) — перехватывает вызов функции.
\n 6) construct(target, argsList, newTarget) — перехватывает вызов конструктора через new.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Анимация CSS vs JS",
        answer: `Нужно использовать CSS  для простых анимаций, а JavaScript для более сложных и динамичных. 
\n Из плюсов анимаций CSS:
\n 1) То, что выше производительность чем через JS.
\n 2) Они более простые: Для простых анимаций, таких как изменение цвета, размера, перемещение элементов, CSS-анимации проще в использовании и настройке.
\n 3) Легче в обслуживании: Анимации, созданные с помощью CSS, легко поддерживать и изменять, так как они явно определяются в стилях.
\n Из недостатков это: 
\n 1)Ограниченная функциональность: CSS-анимации не позволяют создавать сложные анимации как с помощью JS. Анимации CSS не могут легко изменяться в зависимости от пользовательского взаимодействия или состояния приложения.
`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Что такое чистая функция? Идемпотентность? Детерминированность",
        answer: `Чистая функция - это функция, которая для одних и тех же параметров возвращает один и тот же результат.  не имеет сайд эффектов. Функция не изменяет глобальные переменные, аргументы или объекты, переданные ей. Также она не вызывает побочные эффекты, такие как изменения в DOM, вывод в консоль или работа с файлами

\nДополнительно:
В Redux записи в localstorage делали в useEffect, createSyncThunk.

\n Детерминированность означает, что функция всегда возвращает один и тот же результат для одних и тех же аргументов. Это свойство позволяет предсказать результат работы функции, если известны её аргументы.

\n Идемпотентность — это свойство функции, при котором, независимо от того, сколько раз операция выполняется, результат остаётся таким же, как после первого применения.`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Как скопировать полностью объект?",
        answer: `1) Самый простой способ глубокого копирования объекта — это использование JSON-методов, хотя этот метод имеет ограничения:он Не копирует функции, Не копирует символы, Не поддерживает специальные объекты, такие как Date, Map, Set, RegExp, и другие нестандартные объекты.
        \n 2) через Рекурсивное копирование с помощью цикла 
        \n 3) Использовать библиотеки`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про KISS, DRY, YANGI, SOLID",
        answer: `Эти принципы программирования.
\n KISS (Keep It Simple, Stupid) -  Писать код как можно проще. Сложность добавляет больше мест для ошибок, делает код сложнее в поддержке и разборе.
\n DRY (Don't Repeat Yourself) - Избегать дублирования кода. Если одна и та же логика повторяется в разных местах программы, её стоит вынести в отдельную функцию.
\n YAGNI (You Aren't Gonna Need It) - Не стоит реализовывать функционал, который возможно потребуется в будущем, но не нужен на текущем этапе. 
\n SOLID - Это набор из пяти принципов объектно-ориентированного программирования, которые делают код более гибким, модульным и устойчивым к изменениям.
\n - S (Single Responsibility Principle) Единственной ответственности: класс или функция должны быть ответственны за выполнение только одной задачи.
\n - O (Open/Closed Principle) открытости/закрытости: функции, классы, модули должны быть открыты для расширения, но закрыты для модификации.
\n - L (Liskov Substitution(сабститишин) Principle) Барабары Лисков: Объекты базового класса должны быть заменяемы объектами производного класса без нарушения логики.
\n - I (Interface Segregation(сегретейшин) Principle): разделения интерфейса Клиенты не должны зависеть от интерфейсов, которые они не используют. Это значит, что нужно разделять большие интерфейсы на более узкие, специфичные для задач.
\n - D (Dependency Inversion Principle) Инверсии зависимости: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа должны зависеть от абстракций. То есть, зависимости в коде должны строиться на интерфейсах, а не на конкретных реализациях`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про Cookie, localStorage, SessionStorage, IndexDB",
        answer: `Это технологии для хранения данных на стороне клиента в браузере. 
        \n Cookies — это строка данных, максимум 4KB, которая хранится на клиенте и состоит из пар "ключ-значение". Один домен может содержать около 180–200 cookies, что суммарно составляет около 700KB. 
        \n Куки обладают особыми флагами, которые определяют их поведение:
        \n 1) HttpOnly — делает cookie недоступной для JavaScript, обеспечивая дополнительную защиту от XSS-атак.
        \n 2) Secure — указывает, что cookie должна передаваться только через HTTPS-соединение.
        \n 3) SameSite — определяет, может ли cookie отправляться с запросами, исходящими с другого домена. Например, при значении SameSite=Strict cookie не будет передаваться, если пользователь перешел на сайт по ссылке из письма.
        \n Время жизни cookie задается через атрибуты Expires (конкретная дата) или Max-Age (время в секундах). Когда срок действия истекает, cookie автоматически удаляется.
        \n Cookies часто применяются для управления сессиями, аутентификации пользователей, хранения токенов или пользовательских настроек.(document.cookie, для удаления прошлую дату указать)
        
        \n LocalStorage и SessionStorage. Максимальный размер у них до 5-10 мб в зависимости от браузера. У LocalStorage данные сохраняются без ограничения по времени. Даже если пользователь закроет и заново откроет браузер, данные останутся доступными. У SessionStorage после закрытия вкладки или окна данные удаляются. Данные доступны только на клиенте. (LocalStorage.setItem, getItem, removeItem, clear)
LocalStorage применяется для сохранения настройки темы, предпочтения пользователя, корзина покупок. а Session Storage для временной информации которая нужна в рамках одной сессии.

        \n IndexedDB — низкоуровневая база данных, позволяющая хранить значительные объемы данных(объекты JS). Она является асинхронной. IndexedDB позволяет хранить объекты, массивы, строки и файлы, благодаря возможности работы с объектными хранилищами (object stores).  Объектные хранилища (object stores) являются аналогом таблиц, где данные хранятся в виде ключ-значение. Индексы позволяют быстро искать данные по конкретным полям.
        \n Все операции в IndexedDB (добавление, удаление, обновление данных) происходят в рамках транзакций, что обеспечивает целостность данных. Если транзакция завершается неудачно, изменения откатываются. Чтобы работать с IndexedDB, используется API, предоставляющий объект indexedDB, который позволяет:
\n Открывать базы данных (indexedDB.open),
\n Создавать или изменять хранилища данных и индексы,
\n Выполнять операции чтения, записи, удаления и обновления данных.
 \n IndexedDB используется:
    \n 1) Офлайн-приложения: IndexedDB идеально подходит для работы в оффлайн-режиме, так как позволяет сохранять данные локально и синхронизировать их с сервером при подключении.
    \n 2) Кэширование больших данных: Web-приложения могут использовать IndexedDB для кэширования больших объемов данных, что ускоряет повторные загрузки и работу с данными.
    \n 3) Для сложных веб-приложения: Приложения, такие как редакторы, игры и инструменты для работы с мультимедиа, могут использовать IndexedDB для хранения промежуточных данных или пользовательских настроек.
\n Преимущества IndexedDB:
\n - Поддержка транзакций и индексов.
\n - Возможность асинхронной работы с данными.
\n - Кросс-браузерная поддержка.
\n - Хорошо подходит для долгосрочного хранения больших объемов данных.
`,
        categories: ["platina2", 'react', "all"]
    },
    {
        question: "Расскажи про Promise, async/await",
        answer: `Promise — это объект, представляющий результат асинхронной операции. Он может находиться в одном из трех состояний:
\n - Pending (ожидание) — операция ещё не завершена.
\n - Fulfilled (выполнено) — операция завершена успешно.
\n - Rejected (отклонено) — операция завершена с ошибкой.
\n Promise создается при помощи конструктора new Promise, который принимает функцию с двумя параметрами: resolve и reject. Эта функция выполняется сразу же и используется для того, чтобы перевести Promise из состояния "ожидание" в одно из двух конечных состояний. У промиса есть подписчики обработчики:
\n - then() — используется для обработки успешного результата, когда будет resolve.
\n - catch() — используется для обработки ошибок, когда будет reject
\n - finally() — вызывается в любом случае, независимо от того, завершился ли Promise с ошибкой или успешно.
\n Методы Promise:
\n 1) Promise.all() - принимает массив промисов и возвращает новый промис, который выполнится, когда все промисы из массива будут выполнены. Если хотя бы один из промисов будет отклонен, то Promise.all() вернет отклоненный промис с причиной ошибки.
\n 2) Promise.race() - возвращает промис, который выполнится или отклонится первым из переданного массива.
\n 3) Promise.any() - возвращает промис, который выполнится, когда выполнится хотя бы один промис из массива
\n 4) Promise.allSettled() - возвращает новый промис, который выполнится, когда все промисы из массива завершатся, независимо от того, были они выполнены успешно или с ошибкой. Результат будет содержать массив объектов, каждый из которых содержит состояние (status) и результат выполнения или причину отклонения промиса.

\n async/await — это синтаксический сахар, который упрощает работу с асинхронным кодом на основе Promises. Функция, помеченная как async, автоматически возвращает Promise. Внутри этой функции можно использовать await для приостановки выполнения пока Promise не выполнится или не будет отклонен.
Вместо использования catch для обработки ошибок в цепочке промисов, можно просто использовать try/catch внутри async функции.
`,
        categories: ["platina2", 'react', "all"]
    },
    {
        "question": "Почему выбрано направление frontend и JavaScript?",
        "answer": "Изначально когда поступал в институт хотел научиться создавать сайты. И при поступлении специально выбирал направление, где будет обучение веб-разработки. Нравится что можно сразу видеть то, что ты создаешь, нравится создавать интерфейс. JavaScript привлек своей популярностью и возможностью работы как на клиентской, так и на серверной стороне, а также огромным количеством библиотек.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Ближайшие планы на будущее",
        "answer": "Мои ближайшие планы включают углубление знаний в области производительности приложений, улучшать знания в DevOps, изучение новых возможностей React и других фреймворков, а также улучшение своих знаний по архитектуре приложений. И также больше погружаться именно в бизнес.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Какие способы изоляции стилей ты знаешь?",
        "answer": "CSS Modules: Изолируют стили, генерируя уникальные классы на уровне сборки.\nStyled Components и другие CSS-in-JS библиотеки: Стили пишутся внутри компонентов и изолированы на уровне компонента.\nShadow DOM: Используется в Web Components для полной изоляции стилей и разметки.\nBEM (Block Element Modifier): Методология наименования классов, которая помогает избежать пересечения стилей.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Какие были обязанности в прошлом проекте?",
        "answer": "В прошлом проекте я занимался разработкой системы мониторинга транспорта в реальном времени с интеграцией картографических сервисов. Мои обязанности включали работу с React, WebSocket, создание интерактивных карт на основе React-Leaflet, визуализацию данных с помощью React-Charts, настройку 3D-элементов с Three.js и стилизацию компонентов с Tailwind CSS.\nВ прошлом проекте мои обязанности включали:\nРазработка логики образовательной платформы: Использование React, MobX-State-Tree и TypeScript для создания масштабируемого и высокопроизводительного приложения.\nСоздание мульти-steps формы: Интеграция React Hook Form с валидацией на основе Yup для создания переиспользуемых форм.\nРазработка анимаций: Реализация различных видов анимаций, включая Drawer, popups и модальные окна.\nДоработка UiKit и Storybook: Внедрение и улучшение компонентов, включая виртуализированный Select для работы с большими данными.\nРабота над Оптимизацией: Работа над производительностью через Lighthouse, web vitals, использование хуков для уменьшения рендеров.\nРазработка различного интерфейса и взаимодействие с бэкендом: Создание таблиц с фильтрами, модальных окон для аватаров, интеграция REST API для получения статистики.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое дженерик?",
        "answer": "Дженерики в TypeScript позволяют создавать обобщенные функции и классы, которые могут работать с различными типами данных, сохраняя безопасность. Это позволяет повторно использовать код для разных типов данных, не теряя при этом контроля над типами.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "В чем разница между forEach и map?",
        "answer": "forEach: Метод массива, который выполняет указанную функцию один раз для каждого элемента массива. Не возвращает новое значение, только выполняет операцию.\nmap: Возвращает новый массив, в котором каждый элемент был изменен согласно переданной функции. Оригинальный массив остается неизменным.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое мемоизация?",
        "answer": "Мемоизация — это оптимизация функций за счет сохранения результатов их выполнения. Если функция вызывается повторно с теми же аргументами, результат берется из кэша, а не вычисляется заново. Это помогает повысить производительность за счет избежания повторных вычислений.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Можешь рассказать о семантическом версионировании?",
        "answer": "Семантическое версионирование (semver) — это система версионирования, которая состоит из трех чисел: MAJOR.MINOR.PATCH. Каждое из чисел увеличивается в зависимости от типа изменений:\nMAJOR: Значительные изменения, которые ломают обратную совместимость.\nMINOR: Новая функциональность, которая совместима с предыдущими версиями.\nPATCH: Исправления ошибок и улучшения, которые не ломают совместимость и не добавляют нового функционала.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Расскажите про свой опыт работы в команде",
        "answer": "Я работал в Scrum-командах, состоящих из frontend и backend разработчиков, дизайнеров, тестировщиков и менеджеров продукта. Мои обязанности включали разработку интерфейсов, взаимодействие с backend через API, участие в код-ревью и тесное сотрудничество с другими разработчиками для достижения общих целей. Мы активно обсуждали архитектуру, проводили груминги, планирования и ретро.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое REST API?",
        "answer": "REST API (Representational State Transfer) — это архитектурный стиль для создания веб-сервисов. REST использует HTTP-запросы для выполнения операций над ресурсами, такими как GET, POST, PUT, DELETE, что позволяет клиентам взаимодействовать с сервером с минимальной задержкой.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое контекст в функции?",
        "answer": "Контекст в JavaScript — это объект, к которому привязывается функция при её вызове. Внутри функции контекст представлен через ключевое слово this. Контекст зависит от способа вызова функции и может быть изменен с помощью методов call, apply, или bind.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Структура HTTP-запроса",
        "answer": "HTTP-запрос состоит из:\nСтартовая строка: Метод запроса (GET, POST и т.д.), URL, версия протокола.\nЗаголовки: Метаданные о запросе (например, Content-Type, Authorization).\nТело: Непосредственно данные, которые передаются (обычно для POST, PUT запросов).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Git-flow?",
        "answer": "Git-flow — это модель ветвления в Git, которая помогает управлять разработкой. Она включает несколько основных веток: master (или main), develop, и временные ветки для feature, release и hotfix. Эта модель помогает управлять процессом разработки, тестирования и выпуска новых версий продукта.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что означает слово \"каскад\" в CSS?",
        "answer": "Каскад в CSS описывает механизм, по которому браузер применяет стили к элементам на основе приоритетов и специфичности. Если несколько правил применимы к одному и тому же элементу, применяется правило с более высоким приоритетом, либо последнее объявленное правило.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как было организовано код-ревью?",
        "answer": "Код-ревью проводилось через pull requests, было перекрестное код-ревью. Каждый разработчик создавал PR для своих изменений, и его коллеги оставляли комментарии и замечания, если находили ошибки или возможности для улучшения. После одобрения нескольких участников PR сливался в основную ветку.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как взаимодействуешь с командой?",
        "answer": "Я участвую в обсуждениях архитектуры и планировании задач. Моя работа заключается в том, чтобы не только писать код, но и поддерживать конструктивное общение внутри команды, делиться знаниями и помогать коллегам решать технические вопросы.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как работает наследование в CSS?",
        "answer": "Наследование в CSS позволяет элементам унаследовать стили от своих родительских элементов. Однако не все свойства наследуются автоматически (например, font-size наследуется, а margin — нет). Наследуемые свойства можно явно указать через ключевое слово inherit.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как ставятся задачи?",
        "answer": "Мы работали по Scrum, задачи распределялись на спринт. На грумингах обсуждались основные задачи, оценивались по сложности и разбивались на подзадачи. Планирование происходило на основе приоритетов бизнеса, а задачи назначались на разработчиков исходя из их опыта и загруженности.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "В чем разница между display: inline и display: inline-block?",
        "answer": "display: inline не позволяет задавать ширину и высоту элемента, он занимает только необходимое место. display: inline-block позволяет задавать размеры элемента, при этом он остается в строке с другими элементами.",
        "categories": ["platina3", "all"]
    },
    {
        question: "Что такое SOLID?",
        answer: "SOLID — это набор принципов объектно-ориентированного программирования, который помогает писать код, который легко поддерживать и расширять:\nSingle Responsibility: Каждый класс должен отвечать за одну задачу.\nOpen/Closed: Классы должны быть открыты для расширения, но закрыты для изменения.\nLiskov Substitution: Объекты должны заменяться их подтипами без изменения корректности программы.\nInterface Segregation: Интерфейсы должны быть специфичными для клиентов.\nDependency Inversion: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.",
        categories: ["platina3", "all"]
    },
    {
        "question": "Что такое XML?",
        "answer": "XML (eXtensible Markup Language) — язык разметки, используемый для хранения и передачи данных в человекочитаемом виде. Он часто применяется для обмена данными между системами и является платформонезависимым. Синтаксис: Иерархический, с вложенными тегами, которые описывают структуру данных. Использование: Чаще всего применяется для описания конфигураций, в веб-службах (SOAP), RSS, и в некоторых форматах файлов (например, .svg).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Достоинства и недостатки препроцессоров CSS, для чего используется, что это такое?",
        "answer": "CSS препроцессоры — это инструменты, которые расширяют функциональность стандартного CSS и позволяют использовать переменные, вложенные селекторы, миксины, функции и другие конструкции. Популярные препроцессоры: SASS, LESS, Stylus.\nПреимущества: \n1) Переменные: Позволяют переиспользовать значения, такие как цвета или размеры, по всему проекту. \n2) Вложенные селекторы: Более чистый и читаемый код, который соответствует структуре HTML. \n3) Миксины и функции: Позволяют создавать переиспользуемые блоки стилей. \n4) Наследование: Улучшает структуру и повторное использование кода.\nНедостатки:\n1) Компиляция: CSS препроцессоры требуют компиляции в стандартный CSS перед выполнением в браузере. \n2) Поддержка инструментов: Не все инструменты разработки или IDE поддерживают препроцессоры из коробки.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как вы обеспечиваете отображение страниц в старых браузерах?",
        "answer": "Отображение страниц в старых браузерах обеспечивается несколькими способами:\n1) Polyfills: Скрипты, которые эмулируют функции современных браузеров в старых версиях. Например, библиотеки типа Babel или core-js добавляют поддержку современных JavaScript-функций.\n2) Autoprefixer: Инструмент, который автоматически добавляет вендорные префиксы для CSS свойств, обеспечивая кроссбраузерную совместимость.\n3) Graceful degradation: Подход, при котором приложение разрабатывается с использованием современных технологий, но при этом предоставляет упрощенную версию для старых браузеров.\n4) Progressive enhancement: Обратный подход, при котором создается базовая версия сайта для всех браузеров, а затем добавляются более сложные функции для поддерживаемых браузеров.\n5) Can I Use: Использование сайтов вроде 'Can I Use' для проверки поддержки определенных фич в различных браузерах.\n6) Modernizr: Библиотека, которая позволяет проверять, какие возможности поддерживаются браузером и в зависимости от этого предоставлять альтернативные решения.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Расскажи про медиа-запросы",
        "answer": "Медиа-запросы позволяют адаптировать стили в зависимости от характеристик устройства, на котором отображается сайт. Чаще всего используются для создания адаптивных макетов, которые выглядят корректно на различных устройствах. Пример простого медиа-запроса для изменения стилей на мобильных устройствах:\n@media (max-width: 768px) {\n  body {\n    background-color: lightblue;\n  }\n}\nЭтот медиа-запрос изменяет цвет фона страницы на голубой, если ширина экрана не превышает 768 пикселей.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Какие есть подводные камни в оптимизации производительности CSS?",
        "answer": "Подводные камни включают:\n1) Сложные селекторы: Селекторы, которые требуют много шагов для их применения (например, вложенные селекторы или селекторы по атрибутам), могут замедлить рендеринг.\n2) Многочисленные CSS-файлы: Несколько подключаемых CSS-файлов увеличивают количество HTTP-запросов, что замедляет загрузку страницы.\n3) Перегруженные стили: Избыток правил и избыточные стили могут увеличить размер CSS и замедлить время рендеринга.\n4) Неправильное использование анимаций: Использование CSS-анимаций на больших количествах элементов может вызывать reflow и repaint, что отрицательно сказывается на производительности.\n5) @import: Использование @import может замедлить загрузку стилей, так как они грузятся только после загрузки основного CSS-файла.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Объясни, как браузер понимает, на какие элементы накладывать CSS стили?",
        "answer": "Браузер использует механизм каскадности (Cascading) для определения, какие стили применяются к элементам. Это включает три основных шага:\n1) Селекторная фаза: Браузер анализирует HTML и сопоставляет селекторы CSS с DOM-элементами, используя правила специфичности. Чем выше специфичность, тем больше приоритет у стиля.\n2) Специфичность: Степень приоритета определенных селекторов. Например, идентификаторы имеют более высокий приоритет, чем классы или теги.\n3) Наследование: Некоторые CSS-свойства передаются потомкам (например, color), другие — нет (например, margin).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Расскажи про БЭМ",
        "answer": "БЭМ (Блок, Элемент, Модификатор) — это методология для написания CSS, которая делает код более понятным, поддерживаемым и переиспользуемым. Она основывается на разделении кода на независимые блоки.\nБлок: Независимый компонент, например, меню (menu).\nЭлемент: Часть блока, которая не может существовать без него, например, элемент меню (menu__item).\nМодификатор: Различная вариация блока или элемента, например, активный элемент меню (menu__item--active).\n<div class=\"menu\">\n  <div class=\"menu__item menu__item--active\">Home</div>\n  <div class=\"menu__item\">About</div>\n</div>\nМетодология БЭМ помогает четко структурировать код и избежать конфликтов стилей.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "У JS лексическое окружение или динамическое?",
        "answer": "JavaScript использует лексическое окружение (lexical environment). Это означает, что область видимости переменной определяется на этапе написания кода, а не во время исполнения. Переменные и функции 'привязаны' к контексту, в котором они были объявлены.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Структуры данных в JS",
        "answer": "JavaScript поддерживает следующие структуры данных: Простые типы данных: String, Number, Boolean, Null, Undefined, Symbol, BigInt. Объекты: Массивы, объекты, карты (Map), множества (Set). Специальные структуры: Map: Коллекция ключ-значение, которая сохраняет порядок вставки. Set: Коллекция уникальных значений, без дубликатов. WeakMap/WeakSet: Специальные версии Map и Set, которые не предотвращают сборку мусора для объектов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Отличие классов от прототипов",
        "answer": "Классы — это синтаксический сахар в JavaScript, введенный в ES6, который упрощает работу с объектами и наследованием. Классы используют прототипное наследование под капотом, но предоставляют более удобный интерфейс для работы с объектами. Прототипы — это основа наследования в JavaScript. Каждый объект в JS имеет скрытое свойство [[Prototype]], которое указывает на другой объект. В случае отсутствия свойства или метода у текущего объекта JavaScript будет искать его в прототипе.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Области видимости в JS",
        "answer": "В JavaScript есть три типа областей видимости: Глобальная область видимости: Переменные и функции, объявленные вне любых блоков или функций, доступны везде в программе. Функциональная область видимости: Переменные, объявленные внутри функции, доступны только внутри этой функции. Блочная область видимости: Введена в ES6 с использованием let и const. Переменные, объявленные внутри блока ({}), доступны только в этом блоке.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Методы для работы с DOM",
        "answer": "document.getElementById(): Возвращает элемент по его ID. document.querySelector(): Возвращает первый элемент, соответствующий заданному CSS-селектору. document.querySelectorAll(): Возвращает все элементы, соответствующие селектору. createElement(): Создает новый элемент. appendChild(): Добавляет элемент в качестве последнего дочернего к элементу-родителю. removeChild(): Удаляет дочерний элемент.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Где применяются анонимные функции?",
        "answer": "Анонимные функции в JavaScript используются там, где нет необходимости присваивать функции имя, особенно когда функция создается и используется однократно. Примеры использования: Callbacks (Обратные вызовы): Анонимные функции часто применяются в качестве обратных вызовов в методах массивов или в асинхронных операциях, таких как setTimeout, addEventListener, и Promise. setTimeout(() => console.log('Hello'), 1000). Функции высшего порядка: Используются в методах массива, таких как map, filter, forEach. const numbers = [1, 2, 3]; const doubled = numbers.map(num => num * 2). IIFE (Immediately Invoked Function Expression): Анонимные функции можно вызывать немедленно после их объявления.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Замыкание в React и Redux",
        "answer": "Замыкание в React и Redux работает так же, как в обычном JavaScript: это функция, которая 'запоминает' окружение, в котором она была создана, даже после выхода из этого окружения. React: В компонентах React замыкания используются для хранения значений состояния и других переменных. Например, при использовании хуков useState и useEffect, замыкания могут помочь 'запомнить' значения между рендерами. Redux: В Redux замыкания могут быть полезны при создании action creators и middleware, которые имеют доступ к состоянию или параметрам, переданным при их создании.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Приоритет операторов в JS",
        "answer": "Приоритет операторов определяет порядок выполнения операций в выражении. Операторы с более высоким приоритетом выполняются раньше операторов с более низким приоритетом. Порядок приоритетов: Скобки (), Операторы инкремента/декремента ++, --, Унарные операторы +, -, Умножение, деление *, /, Сложение, вычитание +, -, Логические операторы &&, ||.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что находится в прототипе Number, String, Date?",
        "answer": "Прототипы, такие как Number.prototype, String.prototype, Date.prototype, содержат методы, которые могут использоваться экземплярами этих типов. Number.prototype: toFixed(), toString(). String.prototype: indexOf(), toUpperCase(), slice(). Date.prototype: getFullYear(), getMonth(), getTime().",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Паттерны проектирования",
        "answer": "Паттерны проектирования — это повторяющиеся решения общих проблем, возникающих при разработке ПО. Примеры: Singleton, Observer, Factory, Decorator.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое композиция функции?",
        "answer": "Композиция функции — это процесс объединения двух или более функций для создания новой функции, которая выполняет каждую из них поочередно.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое функциональное программирование в JS?",
        "answer": "Функциональное программирование — это парадигма программирования, которая акцентирует внимание на использовании чистых функций, неизменяемости данных и избегании побочных эффектов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Основные концепции функционального программирования в JS?",
        "answer": "Чистые функции: Функции, которые не изменяют внешние переменные и возвращают одинаковый результат для одинаковых входных данных.\nНеизменяемость: Данные не изменяются после создания. Вместо этого создаются новые объекты при необходимости изменений.\nФункции высшего порядка: Функции, которые принимают другие функции в качестве аргументов или возвращают функции.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Примеры сайд-эффектов (побочных эффектов)?",
        "answer": "Сайд-эффекты — это любое взаимодействие функции с внешним миром вне рамок возвращаемого значения. Примеры сайд-эффектов:\nИзменение глобальных переменных.\nМодификация переданных объектов или массивов.\nЛогирование в консоль.\nОтправка HTTP-запросов.\nВзаимодействие с DOM.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Преобразование типов?",
        "answer": "Преобразование типов — это процесс, когда одно значение автоматически или явно приводится к другому типу данных.\nПример автоматического преобразования:\nconsole.log('5' + 3); // '53', число 3 преобразуется в строку.\nПример явного преобразования:\nlet num = '5';\nlet convertedNum = Number(num); // 5",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Truthy/Falsy значения?",
        "answer": "Truthy и Falsy значения используются для обозначения значений, которые в условиях приводятся к true или false соответственно.\nFalsy значения: false, 0, \"\" (пустая строка), null, undefined, NaN.\nTruthy значения: Все остальные значения, которые не являются falsy.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Mutable vs Immutable в JS?",
        "answer": "Mutable (изменяемые) данные могут быть изменены после создания. Например, объекты и массивы являются изменяемыми.\nПример:\nconst arr = [1, 2, 3];\narr.push(4); // Массив изменен.\nImmutable (неизменяемые) данные не могут быть изменены после создания. Вместо изменения создаются новые экземпляры данных.\nПример:\nconst arr = [1, 2, 3];\nconst newArr = [...arr, 4]; // Создан новый массив.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "В чем разница между Host и Native объектами?",
        "answer": "Host объекты — это объекты, предоставляемые средой выполнения (например, браузером или Node.js). Они не являются частью языка JavaScript, но предоставляются для взаимодействия с окружением. Примеры в браузере: window, document, XMLHttpRequest.\nNative объекты (или встроенные объекты) — это объекты, которые являются частью самого языка JavaScript. Они определены в спецификации языка. Примеры: Object, Array, Function, String.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Event Propagation?",
        "answer": "Event propagation (распространение событий) описывает, как события распространяются по DOM-дереву. Процесс состоит из трех этапов:\n1. Capturing Phase: Событие идет от корневого элемента документа к цели, проходя через все элементы-родители.\n2. Target Phase: Событие достигает целевого элемента, на котором оно было вызвано.\n3. Bubbling Phase: Событие идет обратно вверх от целевого элемента к корню, проходя через тех же родителей.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое JSON?",
        "answer": "JSON (JavaScript Object Notation) — это текстовый формат для обмена данными, который часто используется для передачи данных между клиентом и сервером. Он удобен для работы с JavaScript, так как легко преобразуется в объекты.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое делегирование событий в JS?",
        "answer": "Делегирование событий позволяет ставить обработчик на родительский элемент и обрабатывать события его дочерних элементов. Это особенно полезно, когда нужно обработать множество дочерних элементов, так как обработчик будет назначен один раз.\nПример делегирования событий:\ndocument.querySelector('#parent').addEventListener('click', function(event) {\n  if (event.target.matches('.child')) {\n    console.log('Child clicked');\n  }\n});",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Расскажи о параллельных операциях в JS?",
        "answer": "JavaScript является однопоточным, но поддерживает параллельные операции через асинхронное программирование (например, с помощью Promises, async/await, и веб-воркеров). Асинхронные операции позволяют выполнять задачи, не блокируя основной поток.\nПримеры параллельных операций:\nАсинхронные HTTP-запросы (fetch, XHR).\nРабота с файлами.\nИспользование Web Workers для выполнения кода в отдельном потоке.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Пример XHR запросов?",
        "answer": "XMLHttpRequest (XHR) — это API для создания асинхронных HTTP-запросов. XHR широко использовался до появления fetch.\nПример XHR-запроса:\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function() {\n  if (xhr.status >= 200 && xhr.status < 300) {\n    console.log(xhr.responseText);\n  }\n};\nxhr.send();",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое AJAX?",
        "answer": "AJAX (Asynchronous JavaScript and XML) — это техника для создания асинхронных запросов к серверу, что позволяет обновлять части веб-страницы без полной перезагрузки. Хотя XML в названии, в настоящее время данные чаще всего передаются в формате JSON.\nПример:\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data));",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое условный рендеринг в React?",
        "answer": "Условный рендеринг в React позволяет рендерить компоненты или элементы в зависимости от условий. Это аналогично условным операторам в JavaScript (if, else, тернарный оператор).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое лифтинг?",
        "answer": "Лифтинг состояния (State Lifting) в React происходит, когда несколько компонентов нуждаются в общем состоянии. В этом случае состояние поднимается в их общего родителя, чтобы можно было передавать его в дочерние компоненты через props.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Render Props?",
        "answer": "Render Props — это паттерн в React, когда компонент принимает функцию в качестве пропса, которую использует для рендеринга своих детей.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое чистые компоненты?",
        "answer": "Чистые компоненты в React — это компоненты, которые рендерят один и тот же результат для одних и тех же пропсов и состояния. Они также оптимизированы для предотвращения ненужных ререндеров с помощью поверхностного сравнения пропсов и состояния.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "В каких случаях можно использовать индекс массива в качестве ключа?",
        "answer": "Ключи в React должны быть уникальными и стабильными, чтобы React мог правильно отслеживать изменения в элементах списка. Использовать индекс массива в качестве ключа можно, но только если:\n1) Список не будет изменяться (добавление, удаление, сортировка элементов).\n2) Данные в списке не будут изменяться.\nОднако использование индекса массива в динамических списках может привести к ошибкам при рендере.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое состояние компонента?",
        "answer": "Состояние компонента (State) в React — это объект, который хранит данные, влияющие на отображение компонента. Состояние компонента динамическое, и изменения в нём вызывают повторный рендер компонента. В функциональных компонентах используется хук useState, а в классовых компонентах — свойство state.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Методы жизненного цикла",
        "answer": "Методы жизненного цикла используются в классовых компонентах React для выполнения кода на различных стадиях жизненного цикла компонента: от его создания до удаления.\nОсновные методы:\n1) constructor(): Инициализация состояния.\n2) componentDidMount(): Выполняется после монтирования компонента в DOM.\n3) componentDidUpdate(prevProps, prevState): Выполняется после обновления компонента.\n4) componentWillUnmount(): Выполняется перед удалением компонента из DOM.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое хуки? Шпаргалка хуков",
        "answer": "Хуки (Hooks) — это функции, позволяющие использовать состояние и другие возможности React в функциональных компонентах. Они были введены в React 16 и позволяют обходиться без классовых компонентов.\nОсновные хуки:\n1) useState: Управление состоянием компонента.\n2) useEffect: Побочные эффекты (аналог методов componentDidMount, componentDidUpdate, и componentWillUnmount).\n3) useContext: Доступ к контексту.\n4) useReducer: Альтернатива для управления состоянием, аналогичная Redux.\n5) useCallback: Мемоизация функций.\n6) useMemo: Мемоизация значений.\n7) useRef: Сохранение mutable переменной, которая не вызывает повторного рендера при изменении.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Какие хуки есть в функциональных компонентах, но их нет в классовых?",
        "answer": "В классовых компонентах нет useState (аналогом является свойство state и метод setState). В классовых компонентах нет useEffect (аналогами являются методы componentDidMount, componentDidUpdate, и componentWillUnmount).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое React Router?",
        "answer": "React Router — это библиотека для управления маршрутизацией в React-приложениях. Она позволяет организовывать переходы между страницами без перезагрузки, поддерживая работу с URL и историю браузера.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Когда используют declare в TypeScript?",
        "answer": "declare в TypeScript используется для объявления переменных или типов, которые определяются за пределами TypeScript-файлов, например, из сторонних библиотек или глобальных переменных, и для объявления внешних модулей.\nПример: declare const API_KEY: string;",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Redux? Какие три основных принципа у Redux?",
        "answer": "Redux — это библиотека для управления состоянием в JavaScript-приложениях. Она часто используется с React для централизованного управления состоянием.\nТри основных принципа Redux:\n1) Единое хранилище: Всё состояние приложения хранится в одном объекте store.\n2) Состояние неизменно: Состояние изменяется только с помощью действий (actions).\n3) Чистые редюсеры: Редюсеры (reducers) — это чистые функции, которые определяют, как состояние изменяется в ответ на действия.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "За счет чего реализован доступ к состоянию Redux из любой части приложения?",
        "answer": "Доступ к состоянию Redux из любой части приложения реализован благодаря использованию store и функции connect (или хука useSelector в функциональных компонентах). Store — это объект, который хранит всё состояние приложения, а функции для доступа к нему позволяют компонентам подписываться на изменения состояния и получать актуальные данные.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Redux Saga, Redux-Thunk, Redux-Toolkit, middleware?",
        "answer": "1) Redux Saga: Это middleware для управления побочными эффектами в Redux, основанный на генераторах. Он позволяет обрабатывать асинхронные действия и побочные эффекты, такие как API-запросы, с помощью функций-генераторов.\n2) Redux-Thunk: Это простой middleware для обработки асинхронных действий в Redux. Он позволяет создавать действия, которые могут возвращать функции вместо объектов, что позволяет обрабатывать асинхронные запросы.\n3) Redux-Toolkit: Это официальный инструмент для упрощения разработки с Redux. Он предоставляет стандартные шаблоны и функции для работы с состоянием, такие как createSlice, configureStore и встроенные middleware.\n4) Middleware: Это промежуточные функции, которые обрабатывают действия перед тем, как они достигнут редюсеров. Они могут использоваться для логирования, обработки асинхронных действий и других побочных эффектов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как запускается Webpack, что такое Gulp, итоговая настройка Webpack?",
        "answer": "1) Webpack: Это модульный бандлер, который используется для сборки JavaScript-приложений. Он анализирует зависимости модулей и создает оптимизированные файлы для использования в браузере. Запуск Webpack обычно выполняется через командную строку с использованием команды webpack или webpack --watch для автоматической пересборки.\n2) Gulp: Это инструмент автоматизации задач, который позволяет автоматизировать такие задачи, как сборка, тестирование, линтинг и минификация файлов. Он использует потоки (streams) и основан на Node.js.\n3) Итоговая настройка Webpack может включать в себя конфигурацию для обработки различных типов файлов (JavaScript, CSS, изображения), настройку плагинов для оптимизации и создание выходных файлов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Git и для чего он нужен?",
        "answer": "Git — это система контроля версий, которая позволяет разработчикам отслеживать изменения в коде, сотрудничать с другими разработчиками и управлять проектами. Она позволяет создавать резервные копии кода, восстанавливать предыдущие версии и работать над несколькими ветками проекта одновременно.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "С какими системами контроля версий работал? (Git, GitLab), расскажи про них",
        "answer": "Git: Это распределенная система контроля версий, которая позволяет каждому разработчику иметь свою собственную копию репозитория. Git позволяет выполнять операции, такие как коммиты, слияния и создание веток локально, без необходимости подключения к удаленному серверу.\nGitLab: Это веб-сервис для хостинга Git-репозиториев и управления проектами. GitLab предоставляет инструменты для совместной работы, такие как управление задачами, ревью кода и CI/CD (непрерывная интеграция и развертывание).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Расскажи про git rebase, git merge. Основные git команды, Как сливать, создавать ветки и в чем их отличие.",
        "answer": "git merge: Команда, которая объединяет изменения из одной ветки в другую. При слиянии Git создаёт новый коммит, который включает изменения из обеих веток.\ngit rebase: Команда, которая переносит изменения из одной ветки на другую, применяя изменения поочередно. Это позволяет избежать создания лишних коммитов слияния, создавая более линейную историю.\nОсновные команды Git:\ngit init: Инициализация нового репозитория.\ngit clone: Клонирование удаленного репозитория.\ngit add: Добавление изменений в индекс.\ngit commit: Фиксация изменений в репозитории.\ngit branch: Просмотр или создание веток.\ngit checkout: Переключение между ветками.\ngit pull: Получение изменений из удаленного репозитория и их слияние.\ngit push: Отправка локальных изменений в удаленный репозиторий.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Чем отличается git pull от git push и зачем нужен git fetch?",
        "answer": "git pull: Команда, которая загружает изменения из удаленного репозитория и сразу же их сливает с текущей веткой. Это сочетание git fetch и git merge.\ngit push: Команда, которая отправляет локальные изменения в удаленный репозиторий.\ngit fetch: Команда, которая загружает изменения из удаленного репозитория, но не сливает их с текущей веткой. Это позволяет просматривать изменения перед тем, как решите их слить.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что делает git checkout?",
        "answer": "Команда git checkout используется для переключения между ветками или для восстановления файлов в рабочем каталоге. Также можно использовать её для создания новых веток.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как посмотреть историю изменений?",
        "answer": "Команда git log используется для просмотра истории изменений в репозитории. Она отображает список коммитов с их идентификаторами, автором, датой и сообщениями.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Перенести коммит из одной ветки в другую",
        "answer": "Для переноса коммита из одной ветки в другую можно использовать git cherry-pick, указывая идентификатор коммита, который нужно перенести.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "git merge vs git rebase",
        "answer": "git merge: Создаёт новый коммит слияния, который объединяет изменения из двух веток, сохраняя их историю.\ngit rebase: Переносит коммиты из одной ветки на другую, создавая линейную историю без коммитов слияния.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Отличие Yarn от NPM",
        "answer": "Yarn и NPM — это менеджеры пакетов для JavaScript, которые используются для установки и управления зависимостями.\nYarn:\nБолее быстрая установка пакетов за счёт кеширования.\nПараллельная установка пакетов.\nИспользует файл yarn.lock для обеспечения одинаковых зависимостей на разных машинах.\nNPM:\nБолее распространённый и встроенный в Node.js.\nВ последних версиях добавлены улучшения производительности и функциональности.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое resolutions в package.json?",
        "answer": "resolutions в package.json — это поле, используемое в Yarn для указания конкретных версий зависимостей, которые должны быть использованы в проекте, независимо от того, какие версии указаны в других зависимостях.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Отличие ^ и ~ перед версией зависимости?",
        "answer": "^: Обновляет зависимости до следующей мажорной версии. Например, ^1.2.3 позволит обновлять до 1.x.x, но не до 2.0.0.\n~: Обновляет зависимости до следующей минорной версии. Например, ~1.2.3 позволит обновлять до 1.2.x, но не до 1.3.0.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое peerDependencies в package.json?",
        "answer": "peerDependencies в package.json — это зависимости, которые необходимы для работы библиотеки, но должны быть установлены в проекте, который использует эту библиотеку. Это позволяет избежать конфликтов версий между библиотеками и основным проектом.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как работает npm install?",
        "answer": "Команда npm install выполняет несколько действий:\nЧтение package.json: NPM считывает файл package.json, чтобы определить, какие зависимости необходимо установить.\nЗагрузка пакетов: NPM загружает указанные зависимости из реестра NPM.\nСоздание node_modules: Загруженные пакеты устанавливаются в папку node_modules в проекте.\nСоздание package-lock.json: Если package-lock.json не существует, NPM создаёт его для фиксирования версий установленных пакетов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое package-lock.json и зачем он нужен?",
        "answer": "package-lock.json — это файл, который фиксирует точные версии зависимостей проекта. Он обеспечивает единообразие в установке зависимостей на разных машинах, гарантируя, что все разработчики работают с одинаковыми версиями библиотек.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое npm audit?",
        "answer": "npm audit — это команда, которая анализирует зависимости проекта на наличие уязвимостей безопасности. Она проверяет установленные пакеты и сообщает о возможных проблемах, а также предлагает решения для их исправления.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое CI/CD?",
        "answer": "CI/CD (непрерывная интеграция и непрерывное развертывание) — это набор практик, направленных на автоматизацию процессов разработки, тестирования и развертывания. CI включает автоматическую сборку и тестирование кода при каждом изменении, а CD обеспечивает автоматическое развертывание приложения на сервере после успешного прохождения тестов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое Kubernetes?",
        "answer": "Kubernetes — это система управления контейнерами, предназначенная для автоматизации развертывания, масштабирования и управления контейнеризованными приложениями. Kubernetes предоставляет возможности для управления жизненным циклом контейнеров, автоматического масштабирования и самовосстановления.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как вы обеспечиваете безопасность веб-приложений?",
        "answer": "Для обеспечения безопасности веб-приложений можно использовать следующие практики:\n1) Аутентификация и авторизация: Использование безопасных методов аутентификации (например, JWT) и контроля доступа.\n2) Защита от XSS и CSRF: Использование технологий для предотвращения межсайтовых скриптовых атак и подделки межсайтовых запросов.\n3) Регулярные обновления: Обновление зависимостей и серверов для устранения уязвимостей.\n4) Шифрование данных: Использование HTTPS для защиты данных в транзите и шифрования чувствительных данных в базе данных.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое микросервисы?",
        "answer": "Микросервисы — это архитектурный стиль, который делит приложение на несколько небольших, независимых сервисов, каждый из которых отвечает за определённую бизнес-логику. Микросервисы взаимодействуют друг с другом через API.\nПреимущества микросервисов:\n1) Масштабируемость: Каждый сервис можно масштабировать независимо.\n2) Гибкость: Разные команды могут работать над разными сервисами, используя разные технологии.\n3) Устойчивость: Сбой одного сервиса не приводит к остановке всего приложения.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое CQRS?",
        "answer": "CQRS (Command Query Responsibility Segregation) — это паттерн проектирования, который разделяет операции чтения и записи. В CQRS команды (изменения состояния) и запросы (чтение данных) обрабатываются отдельно, что позволяет оптимизировать каждую из этих операций.\nПреимущества CQRS:\n1) Оптимизация: Можно использовать разные модели данных для операций чтения и записи.\n2) Гибкость: Упрощает реализацию масштабируемых систем.\n3) Упрощение бизнес-логики: Чёткое разделение ответственности упрощает код.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое PWA (Progressive Web App)?",
        "answer": "PWA (Прогрессивные веб-приложения) — это тип веб-приложений, которые используют современные веб-технологии для предоставления функциональности, схожей с нативными приложениями. PWA может работать офлайн, отправлять уведомления и добавляться на главный экран устройства.\nКлючевые характеристики PWA:\n1) Устойчивость к сбоям: Возможность работать даже без подключения к интернету.\n2) Установка на устройство: Возможность установки на главный экран без необходимости загрузки из магазина приложений.\n3) Быстродействие: Оптимизация загрузки и производительности.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое SEO и как его улучшить?",
        "answer": "SEO (поисковая оптимизация) — это процесс оптимизации веб-сайта для повышения его видимости в поисковых системах. Основные аспекты SEO включают:\n1) Контент: Уникальный, качественный и релевантный контент, который отвечает на вопросы пользователей.\n2) Ключевые слова: Оптимизация контента для ключевых слов, которые пользователи вводят в поисковые системы.\n3) Техническое SEO: Оптимизация структуры сайта, скорости загрузки, метатегов, карты сайта и т.д.\n4) Ссылочная масса: Увеличение количества обратных ссылок на сайт с других авторитетных ресурсов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое DevOps?",
        "answer": "DevOps — это методология, которая объединяет разработку (Dev) и операции (Ops) для улучшения процесса разработки и развертывания программного обеспечения. DevOps нацелена на автоматизацию и интеграцию процессов разработки, тестирования и развертывания, что позволяет ускорить поставку программного обеспечения и улучшить его качество.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое OAuth и как он работает?",
        "answer": "OAuth — это протокол авторизации, который позволяет пользователям предоставлять доступ к своим данным на одном сервисе другому сервису без раскрытия своих учетных данных. OAuth используется для авторизации доступа к API.\nПроцесс авторизации по протоколу OAuth включает несколько этапов:\n1) Регистрация приложения: Приложение регистрируется на сервисе, к которому требуется доступ, и получает идентификатор клиента и секретный ключ.\n2) Запрос авторизации: Пользователь перенаправляется на страницу авторизации, где он предоставляет разрешение на доступ к своим данным.\n3) Получение кода авторизации: После успешной авторизации сервис перенаправляет пользователя обратно в приложение с кодом авторизации.\n4) Получение токена доступа: Приложение использует код авторизации для запроса токена доступа, который затем может использоваться для доступа к защищённым ресурсам.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как вы реализуете международизацию (i18n) в вашем приложении?",
        "answer": "Международизация (i18n) — это процесс подготовки приложения для поддержки различных языков и культур. Вот несколько способов реализации i18n:\n1) Локализация контента: Храните строки, сообщения и текстовые элементы в отдельных файлах локализации для каждого языка.\n2) Использование библиотек: Используйте библиотеки, такие как react-i18next, react-intl или i18next, которые упрощают процесс перевода и управления языковыми ресурсами.\n3) Поддержка форматов даты и времени: Убедитесь, что ваше приложение правильно обрабатывает форматы даты, времени и чисел для разных регионов.\n4) Динамическое переключение языков: Реализуйте возможность смены языка в реальном времени.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Почему важно указывать ширину и высоту для картинок?",
        "answer": "Указание ширины и высоты для изображений в HTML улучшает производительность и пользовательский опыт. Это позволяет браузеру зарезервировать пространство для изображений, предотвращает переформатирование страницы и смещение контента, ускоряет рендеринг и снижает время до первой отрисовки.\n1) Улучшение производительности и предотвращение перерисовок.\n2) Стабильная компоновка страницы.\n3) Быстрая загрузка и сокращение времени до первой отрисовки (FCP).",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Как расшифровывается CSS?",
        "answer": "CSS расшифровывается как Cascading Style Sheets, что означает 'каскадные таблицы стилей'.\n1. Cascading (каскадные): указывает на применение стилей в порядке приоритетов, учитывая специфичность селекторов, порядок расположения в коде и использование `!important`.\n2. Style (стили): описывает, как выглядят HTML элементы (цвета, шрифты, размеры, и т.д.).\n3. Sheets (таблицы): это файлы стилей, которые могут быть внешними, встроенными или инлайновыми.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое миксины?",
        "answer": "Миксины — это способ повторного использования кода в разных контекстах. Они добавляют методы и свойства к классам, помогая избегать дублирования кода. Например, методы миксина могут быть добавлены к прототипу объекта с помощью `Object.assign`. Миксины также популярны в препроцессорах, таких как Sass и Less, для повторного использования стилей.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что такое интерполяция?",
        "answer": "Интерполяция — это процесс вставки значений переменных или выражений в строку для динамической подстановки данных. Это позволяет создавать гибкие строки без сложной конкатенации.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Для чего служат vh и vw при указании размеров?",
        "answer": "`vh` и `vw` — это единицы измерения, которые зависят от размера области просмотра (viewport) браузера. 1vh равен 1% от высоты области просмотра, а 1vw равен 1% от ширины области просмотра. Эти единицы помогают адаптировать дизайн к разным размерам экранов.",
        "categories": ["platina3", "all"]
    },
    {
        "question": "Что делает box-sizing: border-box?",
        "answer": "Свойство `box-sizing: border-box;` изменяет расчет размеров элемента, включая padding и border в общие размеры ширины и высоты элемента. Это упрощает управление размерами, так как заданные `width` и `height` будут включать все внутренние отступы и границы.",
        "categories": ["platina3", "all"]
    }
]