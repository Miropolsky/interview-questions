export const questions = [
    {
        question: "Что происходит, когда мы ввели адрес сайта и нажали Enter?",
        answer: `Сначала нам нужно найти ip адрес сервера с которого мы получим Html документ. Сначала мы смотрим в кеше браузера, если его нет, то мы смотрим в кеше системы, если там нет, то дальше ищется в кеше роутера, если нет то мы идем к DNS серверу, чтобы получить ip адрес. Дальше начинается этап тройного рукопожатия. После этого идем на сервер чтобы получить htmlку. И она отдается (Браузер понимает что это html по заголовку, content-type:  text/html). Дальше из полученного Html документа у нас формируется DOM, CSSOM, Рендер Три(объединяются DOM и CSSOM), дальше происходит этап Layout(рассчитывается размеры, положения элементов, вычисление слоев), после этого этап Compositing(когда все слои объединяются в один слой), дальше этап Paint(применяются background, color), и в конце этап display(Когда показываем что-то пользователю на странице).

        Также существуют блокирующие скрипты и не блокирующие.Они встречаются при парсинге DOMа.Если есть тег скрипт в Html коде, то парсинг останавливается чтобы выполнить скрипты, задерживается построение DOM. 
        Этого можно избежать если использовать атрибуты Async и Defer:
            1)Async - JS скачивается параллельно, не блокирует парсинг, запускается сразу как загрузился.То есть нет гарантии что скрипты будут выполняться последовательно.Например можно использовать для яндекс метрики.
            2) Defer - Не блокирует парсинг HTML, скачивается параллельно.Когда событие DomContentLoaded стрельнуло, и мы точно убедились что DOM построен, выполняются все скрипты.Используется для скриптов, которые зависят от DOM, например, когда скрипт должен манипулировать элементами HTML.`,
        categories: ["general", "all"]
    },
    {
        question: "Что делают атрибуты Async и Defer?",
        answer: `1)Async - JS скачивается параллельно, не блокирует парсинг, запускается сразу как загрузился.То есть нет гарантии что скрипты будут выполняться последовательно.Например можно использовать для яндекс метрики.
            2) Defer - Не блокирует парсинг HTML, скачивается параллельно.Когда событие DomContentLoaded стрельнуло, и мы точно убедились что DOM построен, выполняются все скрипты.Используется для скриптов, которые зависят от DOM, например, когда скрипт должен манипулировать элементами HTML.`,
        categories: ["general", "all"]
    },
    {
        question: "Что такое Рендер три",
        answer: `Рендер три - дерево рендеринга – представление DOM и CSSOM (отображение их вместе, дерево дом нод со стилями к ним)`,
        categories: ["general", "all"]
    },
    {
        question: "Что такое этап Layout?",
        answer: `Layout - в этом этапе для каждого элемента рассчитывается его положение, размер, расчет взаиморасположении элементов на слое, расчет влияния одних элементов на других, вычисление слоев(например свойство трансформ выносится в отдельный слой)
`,
        categories: ["general", "all"]
    },
    {
        question: "Как эффективнее сделать анимацию: через transform/translate или через left?",
        answer: `Через транформ/транслейт, потому что она использует графический редактор(GPU), а не центральный процессор(CPU). Изменения через transform затрагивают только этапы compositing и painting, в то время как изменение left вызывает этап layout, что вызывает пересчет элементов на странице.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое DOM?",
        answer: `Объектная модель документа, которую браузер создает в памяти компьютера, на основании html, который мы получили с сервера. Иными словами, это представление html в виде дерева тегов.
        Основные узлы дом дерева – это html теги(div, p, a), текстовые узлы и атрибутные узлы(класс, айди). DOM нужен для динамического изменения содержимого страницы, взаимодействия с HTML-документом и обновления его структуры. Через DOM API предоставляется доступ к различным объектам, что позволяет изменять атрибуты и стили элементов, а также создавать и удалять их.`,
        categories: ["js", 'general', "all"]
    },
    {
        question: "Что такое CSSOM?",
        answer: `CSSOM (CSS Object Model) — это структура, которая представляет собой объектную модель стилей, аналогичную DOM, но для CSS. Она создаётся браузером параллельно с DOM и описывает все стили, которые будут применяться к элементам на странице.`,
        categories: ["htmlcss", 'general', "all"]
    },
    {
        question: "Что такое CSS In JS?",
        answer: `Подход, который позволяет писать CSS внутри JavaScript. В React стили можно описывать как обычные JavaScript объекты, а затем применять их к компонентам. С помощью такого подхода можно создавать компоненты, которые динамически меняют стили, в зависимости от переданных пропсов.
        Из плюсов: Вендорные префиксы добавляются автоматически  для кроссбраузерной совместимости(например, -webkit-, -moz-, -ms-, -o-), Динамические стили(Легко изменять стили компонентов в зависимости от пропсов)
        Из минусов: увеличение размера JavaScript(его надо подгрузить, распарсить, выполнять, собрать все теги) Дольше отрисовка чем у CSS, неудобно, нельзя разбить на чанки
`,
        categories: ["htmlcss", 'js', 'general', "all"]
    },
    {
        question: "Что такое Cors и какие проблемы он решает?",
        answer: `CORS (Cross-Origin Resource Sharing) — это механизм, который позволяет браузерам запрашивать ресурсы с другого домена, отличного от того, с которого загружается страница. По умолчанию в браузере политика Same-Origin Policy, которая запрещает читать другие ответы от других источников, которые отличаются от источника, с которого был запрос. Например, Если стучимся на бек и в консоле ошибка по корсу. То идем к бекендерам и просим добавить наш url фронта в access control allow origin.
        CORS защищает приложения от потенциальных угроз, обеспечивая, что запросы могут быть отправлены только к безопасным и проверенным источникам. Это предотвращает атаки межсайтового скриптинга(XSS) и подделки запросов(CSRF).
        Когда страница пытается сделать запрос к ресурсу с другого домена, браузер сначала отправляет предварительный запрос (preflight) с методом OPTIONS, чтобы проверить, разрешает ли сервер доступ. Если сервер отвечает с заголовком Access-Control-Allow-Origin и указывает домен, с которого разрешены запросы, браузер позволит доступ к этому ресурсу`,
        categories: ["htmlcss", 'general', "all"]
    },
    {
        question: "Какие есть методы HTTP?",
        answer: `1) GET: Используется для получения данных с сервера. Особенности: Запросы кешируются, передаются параметры через URL (query string), нет тела запроса. 
                 2) POST: Используется для создания новой сущности на сервере. Особенности: Данные передаются в теле запроса. POST-запросы не кешируются. (POST также может использоваться для получения данных, хотя это нарушает принцип REST)
                3) PUT: Используется для полного обновления ресурса. Особенности: Полностью заменяет существующую сущность новыми данными. 
                4) PATCH: Используется для частичного обновления ресурса. Особенности: Обновляет только указанные поля сущности. 
                5) DELETE: Используется для удаления ресурса.
                6) OPTIONS: Используется для получения информации о доступных методах для ресурса. Особенности: Часто используется для предварительных запросов (preflight) в контексте CORS. Браузер отправляет запрос OPTIONS перед отправкой сложного запроса (например, с токенами авторизации), чтобы убедиться, что сервер разрешает запрашиваемый метод.
                7) HEAD: Используется для проверки наличия ресурса или метаинформации (например, заголовков) без загрузки контента. Особенности: Аналогичен методу GET, но без тела ответа.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Отличие Put от Patch?",
        answer: `Put полностью заменяет ресурс, а patch – обновляет конкретные значения(вносит частичные изменения).`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Отличие Get от Post?",
        answer: `get - используется для запроса данных. Не безопасен для передачи конфиденциальных данных, так как передает параметры в URL, может быть кеширован, идемпотентен. есть Etag. А post используется для создания новой сущности. Данные передаются в теле запроса, не кэшируется, не является идемпотентным.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое идемпотентность?",
        answer: `идемпотентный –  многократное выполнение запроса приводит к одному и тому же результату, что и при первом выполнении.
        1) GET: многократное получение ресурса не изменяет состояние сервера.
        2) PUT: многократное обновление ресурса одними и теми же данными приводит к одному и тому же результату.
        3) DELETE: многократное удаление ресурса приводит к одному и тому же результату.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое ETag(ентитег)?",
        answer: `Etag(энтити тег) – Это уникальный хэш, который сервер добавляет к ответу для определения изменения ресурса. Если хэш не изменился, то клиент может использовать данные из кеша.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое Preflight запрос?",
        answer: `Preflight запрос — это специальный запрос, который отправляется перед основным запросом к серверу. Он использует метод OPTIONS и содержит заголовки, такие как Access-Control-Request-Method и Origin, которые информируют сервер о типе предстоящего запроса и происхождении запроса. (Пример: отправка запроса с токеном авторизации в заголовке)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое SSR? Плюсы и минусы?",
        answer: `Server Side Rendering. Клиенту с сервера отдается готовый html. Скачивается CSS, затем JS. Дальше идет этап гидратации(Когда нужно наложить JS на HTML для функциональности и интерактивности)
        Плюсы: Клиент меньше нагружается, СЕО оптимизация, первоначальная загрузка быстрее
        Минусы: Нужны более мощные сервера`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "В чем разница HTTP и HTTPS?",
        answer: `HTTP(Hyper text transfer protocol). S – Secure(безопасность).
        HTTP – работает на 80 порту, HTTPS – на 443.
        Браузер считает что сайты HTTP опасны, туда трафик не пускают.
        HTTPS использует шифрование для защиты данных, передаваемых между клиентом и сервером. Это предотвращает перехват и изменение данных. Предотвращает атаку main-in-the-middle, когда человек стоит в центре между браузером и сервером и как-то перехватывает запросы и как-то обрабатывает.
        HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных. (TLS — это более современная и безопасная версия SSL)
        Как работает HTTPS: 
        1) Для использования HTTPS серверу нужен SSL/TLS сертификат, который подтверждает его подлинность. При создании сертификата сервер получает пару ключей. Публичный ключ доступен всем, а приватный ключ хранится в секрете на сервере. Сертификат содержит публичный ключ и информацию о сервере, подписанную доверенным центром сертификации (CA).
        2) Когда клиент (браузер) подключается к серверу, происходит процесс TLS Handshake: Клиент запрашивает сертификат у сервера, Сервер отправляет свой сертификат, содержащий публичный ключ, Клиент проверяет сертификат с помощью доверенного центра сертификации, Устанавливается защищенное соединение, используя обмен ключами и шифрование.
        Сертификаты выдаются доверенными центрами сертификации, которые проверяют подлинность и идентичность сервера перед выдачей сертификата.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи что такое TCP, content security policy(CSP)?",
        answer: `TCP (Transmission Control Protocol) - это сетевой протокол, который обеспечивает надежную и проверенную доставку данных между приложениями. 
        CSP - стандарт защиты сайтов от атак с внедрением контента. CSP описывает безопасные источники загрузки и блокирует ресурсы, которые не входят в «белый список». При настройки можно добавить в «белый список» источник.
        С помощью CSP, например, можно запретить встроенные скрипты. например есть текст эриа, куда злоумышленник может вставить код. Злоумышленник может написать код с вытягивание данные из куки.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про SOLID, на примере React.",
        answer: `SOLID — это набор пяти принципов объектно-ориентированного программирования, которые помогают создавать более гибкий, поддерживаемый и расширяемый код.
                1) Принцип единственной ответственности (Single Responsibility Principle/разделения интерфейса) – Каждый компонент должен иметь одну единственную ответственность. В контексте React это означает, что компонент должен выполнять только одну задачу или функциональность. Например есть компонент туду листа, и компонент туду айтем, при этом вариант плодить все внутри APP, это против правила, код сложнее будет читать. 

                2) Принцип открытости/закрытости (Open/Closed Principle). В React компоненты должны быть открыты для расширения, но закрыты для модификации. Компонент должен иметь возможность добавлять новый функционал, не изменяя существующий код. У нас есть компонент Button, и мы хотим добавить новый стиль, не меняя исходный код. Мы создадим новый компонент с оберткой старого, а не будем добавлять новый функционал в старый код.
                3) Принцип подстановки Барбары Лисков (Liskov Substitution Principle). Объекты подклассов должны быть взаимозаменяемы с объектами суперклассов. В React это относится к возможности использовать компоненты или функции без необходимости менять код, который их использует. Если у нас есть компонент AnimalSound, который принимает любой компонент, реализующий интерфейс звука животного, мы можем заменить его любым другим компонентом, соответствующим интерфейсу.
                4) Принцип разделения интерфейса (Interface Segregation Principle). Клиенты не должны зависеть от интерфейсов, которые они не используют. В контексте React это может означать, что компоненты должны получать только необходимые им пропсы. Предположим, у нас есть компонент UserCard, который отображает информацию о пользователе. Но вместо передачи ему всех данных о пользователе, мы передаем только те данные, которые ему действительно нужны(name/email без остальных).
                5) Принцип инверсии зависимостей (Dependency Inversion Principle). Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. В React это означает, что компоненты должны зависеть от абстракций (например, через контекст или пропсы), а не от конкретных реализаций. Например, есть react компонент где выполняется запрос, а url прокидывается пропсы.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про ООП. Полиморфизм, абстракция, наследование, инкапсуляция.",
        answer: `В ООП есть полиморфизм, абстракция, наследование и инкапсуляция.
        Полиморфизм – один и тот же метод, может работать по-разному. В React это может быть реализовано через компоненты, которые принимают разные пропсы или рендерят разные элементы в зависимости от контекста. (метод ToString() ).
        Инкапсуляция — приватные поля какие-нибудь в классе. скрытие внутренних деталей реализации компонента. В React это можно реализовать через локальное состояние и методы, которые не доступны извне компонента. Пример: компонент Counter, который инкапсулирует логику управления счетчиком внутри себя.
        Абстракция  — Это концепция, скрытия сложных деталей реализации и предоставление только необходимые свойства и методы. Например, Есть класс машина,  класс транспорт средство – слишком абстрактный классс. Когда мы будем наследоваться в классе машины от транспортного средства, то т/c будет абстракцией. Унаследуют методы и свойства.
        Наследование позволяет создавать новые классы, основанные на существующих, унаследовав их свойства и методы. В контексте React наследование встречается реже, так как чаще используются и функциональные компоненты. Однако наследование может быть полезным при создании классовых компонентов.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи алгоритм регистрации/авторизации/логина?",
        answer: `Когда мы нажимаем на кнопку отправить, на бэкэнд отправляется запрос, бекэнд валидирует полученные данные password и login, если все окей, то нам приходит заголовок Set Cookie и устанавливается куки в браузере. Там есть access и refresh токены(refresh используется для обновления акцесс токена). 
        Дальше есть интерцепторы в axios, есть в axios мидлварена, которая позволяет подписаться на resposonce и request и сделать какую-то работу. Например, если ошибка 401, с ошибкой авторизации, то тогда делаем запрос на бэк с рефреш токеном, чтобы обновить акцесс токен. И нам приходит новая пара токенов акцес и рефреш.
        Access токен нужен только для идентификации пользователя и передаётся в Cookie с флагом http only. 
        Может приходить только access токен(Используется для аутентификации. Обычно короткоживущий (например, 30 минут).
        (Если злоумышленник украдет акцес токен, то тогда он побудет недолгое время до обновления токена. А чтобы его обновить нужен акцес токен.)
        (Эти токены могут быть отправлены в HTTP-заголовке Set-Cookie или в теле ответа.)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое Interceptors (перехватчики)?",
        answer: `Interceptors (перехватчики) — это функция в axios, которая позволяет «перехватить» запросы или ответы до того, как они будут обработаны.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Где хранить токен?",
        answer: `Буду хранить в куки, там есть флаг http онли с помощью которого нельзя будет из JS достучаться до токена.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое JSON Web Token (JWT) ?",
        answer: `JSON Web Token (JWT) — содержит три блока: заголовок(header), набор полей (payload) и сигнатуру. Отделяются точкой. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие).`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Что такое Nginx?",
        answer: `веб-сервера, на котором можно расположить статику фронта. Когда переходишь по домену, nginx обрабатывает запрос и выдает сбуилженный проект. NGinx снижает нагрузку на сервер, балансирует нагрузку, кеширует.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про тесты",
        answer: `Были Юнит-тесты, которые проверяли функциональность отдельных частей, интеграционные, которые проверяли взаимодействие между ними, E2E тесты, которые имитировали действия пользователя, также использовались для тестирования взаимодействие с сервером, Снэпшот-тесты для тестирования внешнего вида приложения.
        1) unit-тесты (использовал React Testing Library, писал юнит-тесты для проверки отдельных функций и компонентов, таких как функции обработки данных, компоненты пользовательского интерфейса и кастомные хуки. Например: Тестирование валидаторов форм, проверка правильности рендеринга компонентов в зависимости от входных данных (props), тестирование логики кастомных хуков.)
        2) Snapshot Тесты(Jest(автоматически создает и сравнивает снэпшоты). Снэпшот-тесты помогали убедиться, что рендеринг компонентов не изменяется после внесения изменений в код. Например, Тестирование отображения UI-компонентов (кнопки, карточки, формы))
        3) E2E(Cypress(Сайпрес) Этот инструмент позволяет тестировать поведение приложения в браузере, имитируя действия пользователя) для взаимодействие с сервером и работу различных частей приложения вместе. Тестирование процесса прохождения курсов или завершения тестов на образовательной платформе.
        4) Интеграционные (использовал Jest и React Testing Library. для проверки взаимодействия нескольких компонентов и сервисов, чтобы убедиться, что они корректно работают вместе. Например, Тестирование работы формы с валидацией и отправкой данных на сервер, проверка взаимодействия компонентов с глобальным состоянием)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про оценку сложности алгоритмов",
        answer: `Есть оценки по времени и памяти алгоритмов. В основном используют временные оценки. Есть константное, логарифмическое, линейное, квадратичное.
            Допустим есть какой-то объект. Надо достать значение по свойству это будет за констаное время. В форичах сложность будет линейная. А например если есть цикл в цикле, то будет квадратичная.
            (Временная сложность показывает, как увеличивается время выполнения алгоритма по мере увеличения объема данных. Пространственная сложность (Space Complexity): Описывает, сколько памяти требует алгоритм во время своей работы, также в зависимости от размера входных данных.)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про docker",
        answer: `Докер – Это ПО для автоматизации развертывания с использованием контейнеров. Контейнеры позволяют упаковать приложение вместе со всеми его зависимостями и окружением, что обеспечивает работу приложения на разных системах. С помощью Docker можно создать образ приложения. Например, для тестирования нового функционала бекэнд скидывает докер, я его быстро разворачиваю у себя. И можно тестировать локально.
        Плюсы:
        Переносимость: приложения в контейнерах могут быть легко перенесены с одной среды на другую, например, с локальной разработки на сервер в облаке.
        Экономия ресурсов: В отличие от виртуальных машин (VM), контейнеры используют меньше системных ресурсов
        Удобство откатиться к предыдущему состоянию. `,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи, что такое семантика в HTML и зачем она нужна.",
        answer: `Семантика в HTML — это использование HTML-тегов, которые явно описывают содержимое и структуру страницы. Семантические теги дают браузерам, поисковым системам и вспомогательным технологиям четкое представление о содержании и его значении на странице. С помощью семантики улучшается СЕО, улучшается доступность для людей с ограниченными возможностями, становится более понятный код. 
        Основные семантические теги в HTML:
        <header>: Задает шапку сайта или раздела.
        <nav>: Определяет навигационное меню.
        <section>: Представляет раздел страницы.
        <article>: Задает независимый и самодостаточный блок контента, например, статью.
        <aside>: Описывает содержимое, связанное с основным контентом, но не являющееся его частью, например, боковая панель.
        <footer>: Определяет нижний колонтитул страницы или раздела.
        <main>: Определяет основной контент страницы.
        <figure> и <figcaption>: Используются для добавления изображений с подписью.
        <time>: Определяет дату и время.
        С помощью семантики Скринридер зачитывает элементы на странице. Также для людей с ограниченными возможностями надо используется атрибуты Area.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи чем полезны даты атрибуты?",
        answer: `В дата атрибуты можно записывать различную информацию. Дата атрибуты ввели чтобы не пересекаться с нативными атрибутами html. Можно присваивать id. Это поможет когда пишем тесты, чтобы обращаться через айди. (data-test-id).
        (при проде есть бабел который удаляет их при сборке)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про псевдоклассы, псевдоэлементы. В чем их преимущества?",
        answer: `Псевдоклассы (:) – это стилизация элементов в зависимости от их состояния или положения. Например, поменять стиль при наведении, фокусе, нажатии. Есть Active, Hover, focus, checked, nth-child first-child, last-child, not, 
        Псевдоэлементы (::) позволяют стилизовать определенные элемент, которые не присутствуют в html разметке. Они используются для добавления декоративных элементов или изменения частей содержимого без изменения HTML. Это Before(до), after (контент до и после элемента),  placeholder(стилизует placeholder), first-line(первая строка текста внутри элемента), first-letter(первая буква), selection(стилизует выделенный текст)
        псевдоэлемент – как будто реальный элемент, а псевдоклассы просто меняет стили при действии.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи вес селекторов по порядку.",
        answer: `инлайн стили(1000), айди(100), классы/псевдоклассы, атрибуты(10), тег/псевдоэлемент(1)
        important(1000) – перекрывает все.(с классом прибавляется)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Как можно выровнять блок по центру",
        answer: `1) С помощью flexbox(display:flex, justify-content: center, aling-items: center)
                 2) С помощью grid( display: grid, place-items: center)
                 3) По горизонтально с помощью margin: 0 auto
                 4) Через абсолютное позиционирование(position: absolute, left: 50%, top: 50%, transform: translate(-50%, -50%)
                 5) Текстовой блок с помощью (text-aling: center)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Как добавить отступ слева и справа?",
        answer: `1) margin: 0 10px;
                 2) через border прозрачный с box-sizing: border-box
                 3) margin-left, margin-right
                 4) margin-inline: 10px (margin-block(по вертикале)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про производительность css анимаций.",
        answer: `1) Для анимаций лучше использовать такие свойства, как transform: translate (а не left) и opacity, (а не display:none), они выносится в отдельный слой, и в отдельном слое анимация происходит плавно, не вызывая перерисовки, не вызывая этап layout. они обрабатываются на уровне GPU, а не CPU(процессор). Нужно избегать дорогих анимаций, которые вызывают этап layout, изменение размеров, отступов, top, left, поскольку требуют они пересчёта всей компоновки и перерисовки.
        2) Минимизировать количество одновременных анимаций.
        3) Использовать will-change, который позволяет заранее сообщить браузеру, какие свойства будут изменяться. Это помогает браузеру оптимизировать обработку и задействовать GPU для этих изменений. (злоупотребление этим свойством может привести к лишнему использованию памяти, поэтому использовать его нужно осторожно и только для тех элементов, которые действительно будут анимироваться)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Grid vs Flex",
        answer: `Flex – представляет собой контейнер. Он одномерен, есть главная ось и побочная ось(колонки, строки). Grid представляет собой сетку, он двумерен.
Грид применяется обычно для общего макета, где были футер, маин, хедер. А флекс для отдельных компонентов.`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "CSS спрайты",
        answer: `Способ объединить несколько изображений в одно. Затем с помощью CSS выбираются определенные области для отображения отдельных изображений. Это снижает нагрузку на сервер(то что один запрос идет, а не несколько).
        Чтобы показать определенное изображение из спрайта, используется свойство background-image для установки спрайта фоном элемента, а свойства background-position для выбора нужного изображения, смещая фон.
        Недостатки: большой размер изображения, что может замедлить начальную загрузку, сложность с позиционированием`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Rem vs em",
        answer: `Em: определяется относительно размера родительского элемента. Если элементу задано значение font-size: 2em, то размер шрифта будет в два раза больше размера шрифта родителя. Em может накапливаться, то есть если внутри элемента, который уже использует em, есть другой элемент, его значение будет умножаться на значение родителя 
        Rem: определяется относительно документа(html), независимо от родительских элементов. Если элементу задано значение font-size: 2rem, это означает, что размер шрифта будет в два раза больше размера шрифта корневого элемента. 
        (rem не накапливается, в отличие от em. Он всегда основывается на размере шрифта корня)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Огромная вложенность селекторов это хорошо?",
        answer: `Нет, это усложнение кода. Если мы захотим изменить придется менять везде, также могут возникнуть проблемы из-за специфичность селектов`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Container query + has. У меня есть UIKit компонент (карточка товара), я дальше использую его в отдельном фронте, есть сайдбар вывожу список самых популярных товаров, есть мэйн часть в которой вывожу список товаров. В мэйн части карточка по-другому выглядит имеет больший размер, масштаб другой. А в сайдабре маленькая карточка (короткое описание, меньше размеры, изображение). Что делать чтобы карточка могла иметь разное представление?",
        answer: `Нужно, когда используем карточку в сайдбаре дополнительно навесить класс, чтобы верстку правильно разместить через css, написать стилизацию . В мейн части тоже прокинуть новую верстку.

        (Про нововведения:
        В новом css вышли контейнер кверис. Это возможность вместо медиа запроса, написать контейнер запрос. Там в зависимости от ширины родительского контейнера написать свои стили. То есть под каждую ширину будут свои стили.
        Из обновления CSS это Введение в обычный CSS - CSS nesting – вложенность стилей(как в SCSS).
        Также Новый Псевдокласс Has – позволяет применить стили к элементу на основе наличия определенных дочерних элементов или других условий.)`,
        categories: ["htmlcss", "all"]
    },
    {
        question: "Расскажи про последнее место работы",
        answer: `Сейчас я работаю в компании, которая занимается разработкой решений для корпоративного сектора. Это заказная разработка, разработка мобильных приложений и сайтов. 
        Лично я занимался разработкой образовательной платформы для корпоративного обучения и повышения квалификации. 
        С помощью этой платформы можно уменьшить время обучения новых сотрудников, отслеживать процесс обучения, проводить тесты для сотрудников. Платформа повышает уровень знаний персонала и способствует их росту и увеличению производительности, что позволяет сэкономить ресурсы компании. 
        На фронте есть дашборды, графики, каталог курсов, сами курсы, конструктор курса,  личный кабинет, разные элементы типа фильтров, модалок, селектов и таблиц. 
        Я работал в команде из 4 фронтенд-разработчиков, тимлида, 2 бэкендера, 2 дизайнера, 1 продуктолог, 2 тестировщика, аналитик. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Дейлики каждый день в начале дня. Релизы делал тимлид.деплой в докере.`,
        categories: ["", "all"]
    },
    {
        question: "Какая была команда на последнем месте работы",
        answer: `Я работал в команде из 4 фронтенд-разработчиков, тимлида, 2 бэкендера, 2 дизайнера, 1 продуктолог, 2 тестировщика, аналитик. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Дейлики каждый день в начале дня. Релизы делал тимлид.деплой в докере.`,
        categories: ["", "all"]
    },
    {
        question: "Какой был стек технологий на последнем месте работы",
        answer: `TypeScript, React, MobX-State-Tree, SCSS, React Router Dom, Headless UI, Gitlab, Axios, Webpack, ESlint, Prettier, React Hook Form.`,
        categories: ["", "all"]
    },
    {
        question: "Сколько человек в комании?",
        answer: `Около 50 челоек. 10 фронтов. Компания тянет одновременно около 3-5 проектов`,
        categories: ["", "all"]
    },
    {
        question: "Где использовалась многошаговая форма",
        answer: `Многошаговая форма использовалась для создания и настройки нового курса. Такой процесс часто требует ввода большого количества информации, и разбивка его на несколько этапов улучшило пользовательский опыт. Этапы:
        Основная информация: Название курса, краткое описание, категория, уровень сложности.
        Настройка контента: Загрузка учебных материалов, добавление модулей и тем, порядок прохождения.
        Настройка доступа: Выбор групп, которые будут иметь доступ к курсу, настройка прав доступа и сроков прохождения.
        Настройка тестов: Добавление тестов, настройка вопросов, количество попыток, вес оценок.
        Предварительный просмотр и подтверждение: Проверка всех введенных данных перед сохранением курса.
        На каждом шаге отправлялся запрос на бэк для сохранения заполнения данных.`,
        categories: ["", "all"]
    },
    {
        question: "Какие у тебя были инетресные задачи",
        answer: ` Если говорить про интересные задачи, которые делал 
        В целом, было интересно разрабатывать проект образовательной платформы, где было много логики, много созвонов с разными членами команды в том числе с беками, чтобы обсуждать контракты. Была работа с uikitом, хорошо выстроенные процессы в команде. 
        Из технических задач занимался разработкой сложной MultiSteps формой, которая позволяла работать абсолютно с любой формой в приложении. До этого у нас в некоторых местах был копипаст, код разрастался.  Было принято решение на ретро завести задачу на создание новой функциональной формы. Я приступил с нуля заниматься ей. Успешно закончил, тем самым сделал одну отправную точку в коде форм. В общем задача была достаточно интересная. 
        Также встала необходимость использовать селекты для фильтров. После добавления селекта в uikit увидел, что при тестирования на реальных данных, лагает селект из-за большого количества элементов. Я предложил лиду внедрять виртуализацию, завели задачу. После внедрения действительно было облегчение, потому что не отрисовывалось большое количество дом нод, поэтому повысилась производительность т.к. этап layout подсчёта размеров и позиции элементов на странице очень дорогой.`,
        categories: ["", "all"]
    },
    {
        question: "Расскажи про первое место работы",
        answer: `До этого я работал в компании Exore, которая занимается заказной разработкой программного обеспечения, преимущественно в области веб-приложений. Я занимался разработкой платформы для клиентской поддержки и работы агентов. Эта платформа была разработана для внешней компании для внутреннего использования и предоставляет инструменты для анализа и отчетности, помогая понять, насколько эффективно работают службы поддержки, какие запросы наиболее частые, и как можно улучшить качество обслуживания. Также платформа упрощает процесс управления тикетами и взаимодействие с клиентами, что способствует повышению производительности и удовлетворенности клиентов.
        На фронте реализованы: дашборды, личный кабинет, статистики ответов, управление тикетами, шаблоны ответов, разные элементы типа фильтров, модалки, таблицы
        Я работал в команде, состоящей из 2 бэкенд-разработчиков, 3 фронтенд-разработчиков, проектного менеджера, дизайнера, аналитика и 2 тестировщиков. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Релизы тимлид делал, деплой в докере.

        ↪️ Если говорить про интересные задачи, которые делал 
        Одной из самых интересных задач для меня было создание интерфейса для управления тикетами, который отображал, сортировал и фильтровал данные в реальном времен. Я впервые в коммерческом проекте работал с WebSocket. До этого я не имел опыта использования этой технологии в реальных проектах, поэтому я с удовольствием взял эту задачу. Работа с WebSocket оказалась интересной, так как позволила мне глубже погрузиться в технологии реального времени, что значительно отличалось от моего предыдущего опыта.
        Еще одной из интересных задач было внедрение выбора цветовой схемы интерфейса (тёмная и светлая темы). Я разработал ThemeProvider и кастомный хук useTheme, используя CSS переменные (var). Это позволило пользователям настраивать интерфейс под свои предпочтения и улучшило общее восприятие

        Была интересная задача с подгрузкой данных при скроле. Для реализации Infinity Scroll я использовал Intersection Observer API, который позволил отслеживать появление элементов на экране и динамически загружать новые данные по мере прокрутки страницы. Это решение повысило производительность, так как данные подгружались только мере необходимости. Также этот функционал я добавил UI Kit. Этой реализацией я не только получил опыт работы с Infinity scroll и interection observer, но и улучшил производительность приложения. `,
        categories: ["", "all"]
    },
]