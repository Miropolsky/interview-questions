export const questions = [
    {
        question: "Что происходит, когда мы ввели адрес сайта и нажали Enter?",
        answer: `Сначала нам нужно найти ip адрес сервера с которого мы получим Html документ. Сначала мы смотрим в кеше браузера, если его нет, то мы смотрим в кеше системы, если там нет, то дальше ищется в кеше роутера, если нет то мы идем к DNS серверу, чтобы получить ip адрес. Дальше начинается этап тройного рукопожатия. После этого идем на сервер чтобы получить htmlку. И она отдается (Браузер понимает что это html по заголовку, content-type:  text/html). Дальше из полученного Html документа у нас формируется DOM, CSSOM, Рендер Три(объединяются DOM и CSSOM), дальше происходит этап Layout(рассчитывается размеры, положения элементов, вычисление слоев), после этого этап Compositing(когда все слои объединяются в один слой), дальше этап Paint(применяются background, color), и в конце этап display(Когда показываем что-то пользователю на странице).

        Также существуют блокирующие скрипты и не блокирующие.Они встречаются при парсинге DOMа.Если есть тег скрипт в Html коде, то парсинг останавливается чтобы выполнить скрипты, задерживается построение DOM. 
        Этого можно избежать если использовать атрибуты Async и Defer:
            1)Async - JS скачивается параллельно, не блокирует парсинг, запускается сразу как загрузился.То есть нет гарантии что скрипты будут выполняться последовательно.Например можно использовать для яндекс метрики.
            2) Defer - Не блокирует парсинг HTML, скачивается параллельно.Когда событие DomContentLoaded стрельнуло, и мы точно убедились что DOM построен, выполняются все скрипты.Используется для скриптов, которые зависят от DOM, например, когда скрипт должен манипулировать элементами HTML.`,
        categories: ['platina1', 'js', 'react', "all"]
    },
    {
        question: "Что делают атрибуты Async и Defer?",
        answer: `1)Async - JS скачивается параллельно, не блокирует парсинг, запускается сразу как загрузился.То есть нет гарантии что скрипты будут выполняться последовательно.Например можно использовать для яндекс метрики.
            2) Defer - Не блокирует парсинг HTML, скачивается параллельно.Когда событие DomContentLoaded стрельнуло, и мы точно убедились что DOM построен, выполняются все скрипты.Используется для скриптов, которые зависят от DOM, например, когда скрипт должен манипулировать элементами HTML.`,
        categories: ["js", 'platina1', "all"]
    },
    {
        question: "Что такое Рендер три",
        answer: `Рендер три - дерево рендеринга – представление DOM и CSSOM (отображение их вместе, дерево дом нод со стилями к ним)`,
        categories: ["react", "js", 'platina1', "all"]
    },
    {
        question: "Что такое этап Layout?",
        answer: `Layout - в этом этапе для каждого элемента рассчитывается его положение, размер, расчет взаиморасположении элементов на слое, расчет влияния одних элементов на других, вычисление слоев(например свойство трансформ выносится в отдельный слой)
`,
        categories: ['platina1', 'js', 'react', "all"]
    },
    {
        question: "Как эффективнее сделать анимацию: через transform/translate или через left?",
        answer: `Через транформ/транслейт, потому что она использует графический редактор(GPU), а не центральный процессор(CPU). Изменения через transform затрагивают только этапы compositing и painting, в то время как изменение left вызывает этап layout, что вызывает пересчет элементов на странице.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Что такое DOM?",
        answer: `Объектная модель документа, которую браузер создает в памяти компьютера, на основании html, который мы получили с сервера. Иными словами, это представление html в виде дерева тегов.
        Основные узлы дом дерева – это html теги(div, p, a), текстовые узлы и атрибутные узлы(класс, айди). DOM нужен для динамического изменения содержимого страницы, взаимодействия с HTML-документом и обновления его структуры. Через DOM API предоставляется доступ к различным объектам, что позволяет изменять атрибуты и стили элементов, а также создавать и удалять их.`,
        categories: ["js", 'react', 'platina1', "all"]
    },
    {
        question: "Что такое CSSOM?",
        answer: `CSSOM (CSS Object Model) — это структура, которая представляет собой объектную модель стилей, аналогичную DOM, но для CSS. Она создаётся браузером параллельно с DOM и описывает все стили, которые будут применяться к элементам на странице.`,
        categories: ["htmlcss", 'js', 'react', 'platina1', "all"]
    },
    {
        question: "Что такое CSS In JS?",
        answer: `Подход, который позволяет писать CSS внутри JavaScript. В React стили можно описывать как обычные JavaScript объекты, а затем применять их к компонентам. С помощью такого подхода можно создавать компоненты, которые динамически меняют стили, в зависимости от переданных пропсов.
        Из плюсов: Вендорные префиксы добавляются автоматически  для кроссбраузерной совместимости(например, -webkit-, -moz-, -ms-, -o-), Динамические стили(Легко изменять стили компонентов в зависимости от пропсов)
        Из минусов: увеличение размера JavaScript(его надо подгрузить, распарсить, выполнять, собрать все теги) Дольше отрисовка чем у CSS, неудобно, нельзя разбить на чанки
`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Cors и какие проблемы он решает?",
        answer: `CORS (Cross-Origin Resource Sharing) — это механизм, который позволяет браузерам запрашивать ресурсы с другого домена, отличного от того, с которого загружается страница. По умолчанию в браузере политика Same-Origin Policy, которая запрещает читать другие ответы от других источников, которые отличаются от источника, с которого был запрос. Например, Если стучимся на бек и в консоле ошибка по корсу. То идем к бекендерам и просим добавить наш url фронта в access control allow origin.
        CORS защищает приложения от потенциальных угроз, обеспечивая, что запросы могут быть отправлены только к безопасным и проверенным источникам. Это предотвращает атаки межсайтового скриптинга(XSS) и подделки запросов(CSRF).
        Когда страница пытается сделать запрос к ресурсу с другого домена, браузер сначала отправляет предварительный запрос (preflight) с методом OPTIONS, чтобы проверить, разрешает ли сервер доступ. Если сервер отвечает с заголовком Access-Control-Allow-Origin и указывает домен, с которого разрешены запросы, браузер позволит доступ к этому ресурсу`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Какие есть методы HTTP?",
        answer: `1) GET: Используется для получения данных с сервера. Особенности: Запросы кешируются, передаются параметры через URL (query string), нет тела запроса. 
                 2) POST: Используется для создания новой сущности на сервере. Особенности: Данные передаются в теле запроса. POST-запросы не кешируются. (POST также может использоваться для получения данных, хотя это нарушает принцип REST)
                3) PUT: Используется для полного обновления ресурса. Особенности: Полностью заменяет существующую сущность новыми данными. 
                4) PATCH: Используется для частичного обновления ресурса. Особенности: Обновляет только указанные поля сущности. 
                5) DELETE: Используется для удаления ресурса.
                6) OPTIONS: Используется для получения информации о доступных методах для ресурса. Особенности: Часто используется для предварительных запросов (preflight) в контексте CORS. Браузер отправляет запрос OPTIONS перед отправкой сложного запроса (например, с токенами авторизации), чтобы убедиться, что сервер разрешает запрашиваемый метод.
                7) HEAD: Используется для проверки наличия ресурса или метаинформации (например, заголовков) без загрузки контента. Особенности: Аналогичен методу GET, но без тела ответа.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Отличие Put от Patch?",
        answer: `Put полностью заменяет ресурс, а patch – обновляет конкретные значения(вносит частичные изменения).`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Отличие Get от Post?",
        answer: `get - используется для запроса данных. Не безопасен для передачи конфиденциальных данных, так как передает параметры в URL, может быть кеширован, идемпотентен. есть Etag. А post используется для создания новой сущности. Данные передаются в теле запроса, не кэшируется, не является идемпотентным.`,
        categories: ["technology", 'react', 'js', 'platina1', , "all"]
    },
    {
        question: "Что такое идемпотентность?",
        answer: `идемпотентный –  многократное выполнение запроса приводит к одному и тому же результату, что и при первом выполнении.
        1) GET: многократное получение ресурса не изменяет состояние сервера.
        2) PUT: многократное обновление ресурса одними и теми же данными приводит к одному и тому же результату.
        3) DELETE: многократное удаление ресурса приводит к одному и тому же результату.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое ETag(ентитег)?",
        answer: `Etag(энтити тег) – Это уникальный хэш, который сервер добавляет к ответу для определения изменения ресурса. Если хэш не изменился, то клиент может использовать данные из кеша.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Preflight запрос?",
        answer: `Preflight запрос — это специальный запрос, который отправляется перед основным запросом к серверу. Он использует метод OPTIONS и содержит заголовки, такие как Access-Control-Request-Method и Origin, которые информируют сервер о типе предстоящего запроса и происхождении запроса. (Пример: отправка запроса с токеном авторизации в заголовке)`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Что такое SSR? Плюсы и минусы?",
        answer: `Server Side Rendering. Клиенту с сервера отдается готовый html. Скачивается CSS, затем JS. Дальше идет этап гидратации(Когда нужно наложить JS на HTML для функциональности и интерактивности)
        Плюсы: Клиент меньше нагружается, СЕО оптимизация, первоначальная загрузка быстрее
        Минусы: Нужны более мощные сервера`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "В чем разница HTTP и HTTPS?",
        answer: `HTTP(Hyper text transfer protocol). S – Secure(безопасность).
        HTTP – работает на 80 порту, HTTPS – на 443.
        Браузер считает что сайты HTTP опасны, туда трафик не пускают.
        HTTPS использует шифрование для защиты данных, передаваемых между клиентом и сервером. Это предотвращает перехват и изменение данных. Предотвращает атаку main-in-the-middle, когда человек стоит в центре между браузером и сервером и как-то перехватывает запросы и как-то обрабатывает.
        HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных. (TLS — это более современная и безопасная версия SSL)
        Как работает HTTPS: 
        1) Для использования HTTPS серверу нужен SSL/TLS сертификат, который подтверждает его подлинность. При создании сертификата сервер получает пару ключей. Публичный ключ доступен всем, а приватный ключ хранится в секрете на сервере. Сертификат содержит публичный ключ и информацию о сервере, подписанную доверенным центром сертификации (CA).
        2) Когда клиент (браузер) подключается к серверу, происходит процесс TLS Handshake: Клиент запрашивает сертификат у сервера, Сервер отправляет свой сертификат, содержащий публичный ключ, Клиент проверяет сертификат с помощью доверенного центра сертификации, Устанавливается защищенное соединение, используя обмен ключами и шифрование.
        Сертификаты выдаются доверенными центрами сертификации, которые проверяют подлинность и идентичность сервера перед выдачей сертификата.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи что такое TCP, content security policy(CSP)?",
        answer: `TCP (Transmission Control Protocol) - это сетевой протокол, который обеспечивает надежную и проверенную доставку данных между приложениями. 
        CSP - стандарт защиты сайтов от атак с внедрением контента. CSP описывает безопасные источники загрузки и блокирует ресурсы, которые не входят в «белый список». При настройки можно добавить в «белый список» источник.
        С помощью CSP, например, можно запретить встроенные скрипты. например есть текст эриа, куда злоумышленник может вставить код. Злоумышленник может написать код с вытягивание данные из куки.`,
        categories: ["technology", 'react', 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи про SOLID, на примере React.",
        answer: `SOLID — это набор пяти принципов объектно-ориентированного программирования, которые помогают создавать более гибкий, поддерживаемый и расширяемый код.
                1) Принцип единственной ответственности (Single Responsibility Principle/разделения интерфейса) – Каждый компонент должен иметь одну единственную ответственность. В контексте React это означает, что компонент должен выполнять только одну задачу или функциональность. Например есть компонент туду листа, и компонент туду айтем, при этом вариант плодить все внутри APP, это против правила, код сложнее будет читать. 

                2) Принцип открытости/закрытости (Open/Closed Principle). В React компоненты должны быть открыты для расширения, но закрыты для модификации. Компонент должен иметь возможность добавлять новый функционал, не изменяя существующий код. У нас есть компонент Button, и мы хотим добавить новый стиль, не меняя исходный код. Мы создадим новый компонент с оберткой старого, а не будем добавлять новый функционал в старый код.
                3) Принцип подстановки Барбары Лисков (Liskov Substitution Principle). Объекты подклассов должны быть взаимозаменяемы с объектами суперклассов. В React это относится к возможности использовать компоненты или функции без необходимости менять код, который их использует. Если у нас есть компонент AnimalSound, который принимает любой компонент, реализующий интерфейс звука животного, мы можем заменить его любым другим компонентом, соответствующим интерфейсу.
                4) Принцип разделения интерфейса (Interface Segregation Principle). Клиенты не должны зависеть от интерфейсов, которые они не используют. В контексте React это может означать, что компоненты должны получать только необходимые им пропсы. Предположим, у нас есть компонент UserCard, который отображает информацию о пользователе. Но вместо передачи ему всех данных о пользователе, мы передаем только те данные, которые ему действительно нужны(name/email без остальных).
                5) Принцип инверсии зависимостей (Dependency Inversion Principle). Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. В React это означает, что компоненты должны зависеть от абстракций (например, через контекст или пропсы), а не от конкретных реализаций. Например, есть react компонент где выполняется запрос, а url прокидывается пропсы.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи про ООП. Полиморфизм, абстракция, наследование, инкапсуляция.",
        answer: `В ООП есть полиморфизм, абстракция, наследование и инкапсуляция.
        Полиморфизм – один и тот же метод, может работать по-разному. В React это может быть реализовано через компоненты, которые принимают разные пропсы или рендерят разные элементы в зависимости от контекста. (метод ToString() ).
        Инкапсуляция — приватные поля какие-нибудь в классе. скрытие внутренних деталей реализации компонента. В React это можно реализовать через локальное состояние и методы, которые не доступны извне компонента. Пример: компонент Counter, который инкапсулирует логику управления счетчиком внутри себя.
        Абстракция  — Это концепция, скрытия сложных деталей реализации и предоставление только необходимые свойства и методы. Например, Есть класс машина,  класс транспорт средство – слишком абстрактный классс. Когда мы будем наследоваться в классе машины от транспортного средства, то т/c будет абстракцией. Унаследуют методы и свойства.
        Наследование позволяет создавать новые классы, основанные на существующих, унаследовав их свойства и методы. В контексте React наследование встречается реже, так как чаще используются и функциональные компоненты. Однако наследование может быть полезным при создании классовых компонентов.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Расскажи алгоритм регистрации/авторизации/логина?",
        answer: `Когда мы нажимаем на кнопку отправить, на бэкэнд отправляется запрос, бекэнд валидирует полученные данные password и login, если все окей, то нам приходит заголовок Set Cookie и устанавливается куки в браузере. Там есть access и refresh токены(refresh используется для обновления акцесс токена). 
        Дальше есть интерцепторы в axios, есть в axios мидлварена, которая позволяет подписаться на resposonce и request и сделать какую-то работу. Например, если ошибка 401, с ошибкой авторизации, то тогда делаем запрос на бэк с рефреш токеном, чтобы обновить акцесс токен. И нам приходит новая пара токенов акцес и рефреш.
        Access токен нужен только для идентификации пользователя и передаётся в Cookie с флагом http only. 
        Может приходить только access токен(Используется для аутентификации. Обычно короткоживущий (например, 30 минут).
        (Если злоумышленник украдет акцес токен, то тогда он побудет недолгое время до обновления токена. А чтобы его обновить нужен акцес токен.)
        (Эти токены могут быть отправлены в HTTP-заголовке Set-Cookie или в теле ответа.)`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Interceptors (перехватчики)?",
        answer: `Interceptors (перехватчики) — это функция в axios, которая позволяет «перехватить» запросы или ответы до того, как они будут обработаны.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Где хранить токен?",
        answer: `Буду хранить в куки, там есть флаг http онли с помощью которого нельзя будет из JS достучаться до токена.`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Что такое JSON Web Token (JWT) ?",
        answer: `JSON Web Token (JWT) — содержит три блока: заголовок(header), набор полей (payload) и сигнатуру. Отделяются точкой. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие).`,
        categories: ["react", 'js', 'platina1', "all"]
    },
    {
        question: "Что такое Nginx?",
        answer: `веб-сервера, на котором можно расположить статику фронта. Когда переходишь по домену, nginx обрабатывает запрос и выдает сбуилженный проект. NGinx снижает нагрузку на сервер, балансирует нагрузку, кеширует.`,
        categories: ["technology", 'platina1', "all"]
    },
    {
        question: "Расскажи про тесты",
        answer: `Были Юнит-тесты, которые проверяли функциональность отдельных частей, интеграционные, которые проверяли взаимодействие между ними, E2E тесты, которые имитировали действия пользователя, также использовались для тестирования взаимодействие с сервером, Снэпшот-тесты для тестирования внешнего вида приложения.
        1) unit-тесты (использовал React Testing Library, писал юнит-тесты для проверки отдельных функций и компонентов, таких как функции обработки данных, компоненты пользовательского интерфейса и кастомные хуки. Например: Тестирование валидаторов форм, проверка правильности рендеринга компонентов в зависимости от входных данных (props), тестирование логики кастомных хуков.)
        2) Snapshot Тесты(Jest(автоматически создает и сравнивает снэпшоты). Снэпшот-тесты помогали убедиться, что рендеринг компонентов не изменяется после внесения изменений в код. Например, Тестирование отображения UI-компонентов (кнопки, карточки, формы))
        3) E2E(Cypress(Сайпрес) Этот инструмент позволяет тестировать поведение приложения в браузере, имитируя действия пользователя) для взаимодействие с сервером и работу различных частей приложения вместе. Тестирование процесса прохождения курсов или завершения тестов на образовательной платформе.
        4) Интеграционные (использовал Jest и React Testing Library. для проверки взаимодействия нескольких компонентов и сервисов, чтобы убедиться, что они корректно работают вместе. Например, Тестирование работы формы с валидацией и отправкой данных на сервер, проверка взаимодействия компонентов с глобальным состоянием)`,
        categories: ["react", 'platina1', 'js', "all"]
    },
    {
        question: "Расскажи про оценку сложности алгоритмов",
        answer: `Есть оценки по времени и памяти алгоритмов. В основном используют временные оценки. Есть константное, логарифмическое, линейное, квадратичное.
            Допустим есть какой-то объект. Надо достать значение по свойству это будет за констаное время. В форичах сложность будет линейная. А например если есть цикл в цикле, то будет квадратичная.
            (Временная сложность показывает, как увеличивается время выполнения алгоритма по мере увеличения объема данных. Пространственная сложность (Space Complexity): Описывает, сколько памяти требует алгоритм во время своей работы, также в зависимости от размера входных данных.)`,
        categories: ["technology", 'platina1', 'js', "all"]
    },
    {
        question: "Расскажи про docker",
        answer: `Докер – Это ПО для автоматизации развертывания с использованием контейнеров. Контейнеры позволяют упаковать приложение вместе со всеми его зависимостями и окружением, что обеспечивает работу приложения на разных системах. С помощью Docker можно создать образ приложения. Например, для тестирования нового функционала бекэнд скидывает докер, я его быстро разворачиваю у себя. И можно тестировать локально.
        Плюсы:
        Переносимость: приложения в контейнерах могут быть легко перенесены с одной среды на другую, например, с локальной разработки на сервер в облаке.
        Экономия ресурсов: В отличие от виртуальных машин (VM), контейнеры используют меньше системных ресурсов
        Удобство откатиться к предыдущему состоянию. `,
        categories: ["technology", 'platina1', "all"]
    },
    {
        question: "Расскажи, что такое семантика в HTML и зачем она нужна.",
        answer: `Семантика в HTML — это использование HTML-тегов, которые явно описывают содержимое и структуру страницы. Семантические теги дают браузерам, поисковым системам и вспомогательным технологиям четкое представление о содержании и его значении на странице. С помощью семантики улучшается СЕО, улучшается доступность для людей с ограниченными возможностями, становится более понятный код. 
        Основные семантические теги в HTML:
        <header>: Задает шапку сайта или раздела.
        <nav>: Определяет навигационное меню.
        <section>: Представляет раздел страницы.
        <article>: Задает независимый и самодостаточный блок контента, например, статью.
        <aside>: Описывает содержимое, связанное с основным контентом, но не являющееся его частью, например, боковая панель.
        <footer>: Определяет нижний колонтитул страницы или раздела.
        <main>: Определяет основной контент страницы.
        <figure> и <figcaption>: Используются для добавления изображений с подписью.
        <time>: Определяет дату и время.
        С помощью семантики Скринридер зачитывает элементы на странице. Также для людей с ограниченными возможностями надо используется атрибуты Area.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи чем полезны даты атрибуты?",
        answer: `В дата атрибуты можно записывать различную информацию. Дата атрибуты ввели чтобы не пересекаться с нативными атрибутами html. Можно присваивать id. Это поможет когда пишем тесты, чтобы обращаться через айди. (data-test-id).
        (при проде есть бабел который удаляет их при сборке)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи про псевдоклассы, псевдоэлементы. В чем их преимущества?",
        answer: `Псевдоклассы (:) – это стилизация элементов в зависимости от их состояния или положения. Например, поменять стиль при наведении, фокусе, нажатии. Есть Active, Hover, focus, checked, nth-child first-child, last-child, not, 
        Псевдоэлементы (::) позволяют стилизовать определенные элемент, которые не присутствуют в html разметке. Они используются для добавления декоративных элементов или изменения частей содержимого без изменения HTML. Это Before(до), after (контент до и после элемента),  placeholder(стилизует placeholder), first-line(первая строка текста внутри элемента), first-letter(первая буква), selection(стилизует выделенный текст)
        псевдоэлемент – как будто реальный элемент, а псевдоклассы просто меняет стили при действии.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи вес селекторов по порядку.",
        answer: `инлайн стили(1000), айди(100), классы/псевдоклассы, атрибуты(10), тег/псевдоэлемент(1)
        important(1000) – перекрывает все.(с классом прибавляется)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Как можно выровнять блок по центру",
        answer: `1) С помощью flexbox(display:flex, justify-content: center, aling-items: center)
                 2) С помощью grid( display: grid, place-items: center)
                 3) По горизонтально с помощью margin: 0 auto
                 4) Через абсолютное позиционирование(position: absolute, left: 50%, top: 50%, transform: translate(-50%, -50%)
                 5) Текстовой блок с помощью (text-aling: center)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Как добавить отступ слева и справа?",
        answer: `1) margin: 0 10px;
                 2) через border прозрачный с box-sizing: border-box
                 3) margin-left, margin-right
                 4) margin-inline: 10px (margin-block(по вертикале)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи про производительность css анимаций.",
        answer: `1) Для анимаций лучше использовать такие свойства, как transform: translate (а не left) и opacity, (а не display:none), они выносится в отдельный слой, и в отдельном слое анимация происходит плавно, не вызывая перерисовки, не вызывая этап layout. они обрабатываются на уровне GPU, а не CPU(процессор). Нужно избегать дорогих анимаций, которые вызывают этап layout, изменение размеров, отступов, top, left, поскольку требуют они пересчёта всей компоновки и перерисовки.
        2) Минимизировать количество одновременных анимаций.
        3) Использовать will-change, который позволяет заранее сообщить браузеру, какие свойства будут изменяться. Это помогает браузеру оптимизировать обработку и задействовать GPU для этих изменений. (злоупотребление этим свойством может привести к лишнему использованию памяти, поэтому использовать его нужно осторожно и только для тех элементов, которые действительно будут анимироваться)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Grid vs Flex",
        answer: `Flex – представляет собой контейнер. Он одномерен, есть главная ось и побочная ось(колонки, строки). Grid представляет собой сетку, он двумерен.
Грид применяется обычно для общего макета, где были футер, маин, хедер. А флекс для отдельных компонентов.`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "CSS спрайты",
        answer: `Способ объединить несколько изображений в одно. Затем с помощью CSS выбираются определенные области для отображения отдельных изображений. Это снижает нагрузку на сервер(то что один запрос идет, а не несколько).
        Чтобы показать определенное изображение из спрайта, используется свойство background-image для установки спрайта фоном элемента, а свойства background-position для выбора нужного изображения, смещая фон.
        Недостатки: большой размер изображения, что может замедлить начальную загрузку, сложность с позиционированием`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Rem vs em",
        answer: `Em: определяется относительно размера родительского элемента. Если элементу задано значение font-size: 2em, то размер шрифта будет в два раза больше размера шрифта родителя. Em может накапливаться, то есть если внутри элемента, который уже использует em, есть другой элемент, его значение будет умножаться на значение родителя 
        Rem: определяется относительно документа(html), независимо от родительских элементов. Если элементу задано значение font-size: 2rem, это означает, что размер шрифта будет в два раза больше размера шрифта корневого элемента. 
        (rem не накапливается, в отличие от em. Он всегда основывается на размере шрифта корня)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Огромная вложенность селекторов это хорошо?",
        answer: `Нет, это усложнение кода. Если мы захотим изменить придется менять везде, также могут возникнуть проблемы из-за специфичность селектов`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Container query + has. У меня есть UIKit компонент (карточка товара), я дальше использую его в отдельном фронте, есть сайдбар вывожу список самых популярных товаров, есть мэйн часть в которой вывожу список товаров. В мэйн части карточка по-другому выглядит имеет больший размер, масштаб другой. А в сайдабре маленькая карточка (короткое описание, меньше размеры, изображение). Что делать чтобы карточка могла иметь разное представление?",
        answer: `Нужно, когда используем карточку в сайдбаре дополнительно навесить класс, чтобы верстку правильно разместить через css, написать стилизацию . В мейн части тоже прокинуть новую верстку.

        (Про нововведения:
        В новом css вышли контейнер кверис. Это возможность вместо медиа запроса, написать контейнер запрос. Там в зависимости от ширины родительского контейнера написать свои стили. То есть под каждую ширину будут свои стили.
        Из обновления CSS это Введение в обычный CSS - CSS nesting – вложенность стилей(как в SCSS).
        Также Новый Псевдокласс Has – позволяет применить стили к элементу на основе наличия определенных дочерних элементов или других условий.)`,
        categories: ["htmlcss", 'platina1', "all"]
    },
    {
        question: "Расскажи про последнее место работы",
        answer: `Сейчас я работаю в компании, которая занимается разработкой решений для корпоративного сектора. Это заказная разработка, разработка мобильных приложений и сайтов. 
        Лично я занимался разработкой образовательной платформы для корпоративного обучения и повышения квалификации. 
        С помощью этой платформы можно уменьшить время обучения новых сотрудников, отслеживать процесс обучения, проводить тесты для сотрудников. Платформа повышает уровень знаний персонала и способствует их росту и увеличению производительности, что позволяет сэкономить ресурсы компании. 
        На фронте есть дашборды, графики, каталог курсов, сами курсы, конструктор курса,  личный кабинет, разные элементы типа фильтров, модалок, селектов и таблиц. 
        Я работал в команде из 4 фронтенд-разработчиков, тимлида, 2 бэкендера, 2 дизайнера, 1 продуктолог, 2 тестировщика, аналитик. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Дейлики каждый день в начале дня. Релизы делал тимлид.деплой в докере.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Какая была команда на последнем месте работы",
        answer: `Я работал в команде из 4 фронтенд-разработчиков, тимлида, 2 бэкендера, 2 дизайнера, 1 продуктолог, 2 тестировщика, аналитик. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Дейлики каждый день в начале дня. Релизы делал тимлид.деплой в докере.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Какой был стек технологий на последнем месте работы",
        answer: `TypeScript, React, MobX-State-Tree, SCSS, React Router Dom, Headless UI, Gitlab, Axios, Webpack, ESlint, Prettier, React Hook Form.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Сколько человек в комании?",
        answer: `Около 50 челоек. 10 фронтов. Компания тянет одновременно около 3-5 проектов`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Где использовалась многошаговая форма",
        answer: `Многошаговая форма использовалась для создания и настройки нового курса. Такой процесс часто требует ввода большого количества информации, и разбивка его на несколько этапов улучшило пользовательский опыт. Этапы:
        Основная информация: Название курса, краткое описание, категория, уровень сложности.
        Настройка контента: Загрузка учебных материалов, добавление модулей и тем, порядок прохождения.
        Настройка доступа: Выбор групп, которые будут иметь доступ к курсу, настройка прав доступа и сроков прохождения.
        Настройка тестов: Добавление тестов, настройка вопросов, количество попыток, вес оценок.
        Предварительный просмотр и подтверждение: Проверка всех введенных данных перед сохранением курса.
        На каждом шаге отправлялся запрос на бэк для сохранения заполнения данных.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Какие у тебя были инетресные задачи",
        answer: ` Если говорить про интересные задачи, которые делал 
        В целом, было интересно разрабатывать проект образовательной платформы, где было много логики, много созвонов с разными членами команды в том числе с беками, чтобы обсуждать контракты. Была работа с uikitом, хорошо выстроенные процессы в команде. 
        Из технических задач занимался разработкой сложной MultiSteps формой, которая позволяла работать абсолютно с любой формой в приложении. До этого у нас в некоторых местах был копипаст, код разрастался.  Было принято решение на ретро завести задачу на создание новой функциональной формы. Я приступил с нуля заниматься ей. Успешно закончил, тем самым сделал одну отправную точку в коде форм. В общем задача была достаточно интересная. 
        Также встала необходимость использовать селекты для фильтров. После добавления селекта в uikit увидел, что при тестирования на реальных данных, лагает селект из-за большого количества элементов. Я предложил лиду внедрять виртуализацию, завели задачу. После внедрения действительно было облегчение, потому что не отрисовывалось большое количество дом нод, поэтому повысилась производительность т.к. этап layout подсчёта размеров и позиции элементов на странице очень дорогой.`,
        categories: ["behavioral", "all"]
    },
    {
        question: "Расскажи про первое место работы",
        answer: `До этого я работал в компании Exore, которая занимается заказной разработкой программного обеспечения, преимущественно в области веб-приложений. Я занимался разработкой платформы для клиентской поддержки и работы агентов. Эта платформа была разработана для внешней компании для внутреннего использования и предоставляет инструменты для анализа и отчетности, помогая понять, насколько эффективно работают службы поддержки, какие запросы наиболее частые, и как можно улучшить качество обслуживания. Также платформа упрощает процесс управления тикетами и взаимодействие с клиентами, что способствует повышению производительности и удовлетворенности клиентов.
        На фронте реализованы: дашборды, личный кабинет, статистики ответов, управление тикетами, шаблоны ответов, разные элементы типа фильтров, модалки, таблицы
        Я работал в команде, состоящей из 2 бэкенд-разработчиков, 3 фронтенд-разработчиков, проектного менеджера, дизайнера, аналитика и 2 тестировщиков. Работали по Scrum, 2-ух недельные спринты с планированием, грумингами, ретро. Релизы тимлид делал, деплой в докере.

        ↪️ Если говорить про интересные задачи, которые делал 
        Одной из самых интересных задач для меня было создание интерфейса для управления тикетами, который отображал, сортировал и фильтровал данные в реальном времен. Я впервые в коммерческом проекте работал с WebSocket. До этого я не имел опыта использования этой технологии в реальных проектах, поэтому я с удовольствием взял эту задачу. Работа с WebSocket оказалась интересной, так как позволила мне глубже погрузиться в технологии реального времени, что значительно отличалось от моего предыдущего опыта.
        Еще одной из интересных задач было внедрение выбора цветовой схемы интерфейса (тёмная и светлая темы). Я разработал ThemeProvider и кастомный хук useTheme, используя CSS переменные (var). Это позволило пользователям настраивать интерфейс под свои предпочтения и улучшило общее восприятие

        Была интересная задача с подгрузкой данных при скроле. Для реализации Infinity Scroll я использовал Intersection Observer API, который позволил отслеживать появление элементов на экране и динамически загружать новые данные по мере прокрутки страницы. Это решение повысило производительность, так как данные подгружались только мере необходимости. Также этот функционал я добавил UI Kit. Этой реализацией я не только получил опыт работы с Infinity scroll и interection observer, но и улучшил производительность приложения. `,
        categories: ["behavioral", "all"]
    },
    {
        question: "Что такое TypeScript? Зачем он нужен?",
        answer: `TS - это языковая надстройка над JavaScript. TS компилируется в чистый JavaScript и полностью совместим с ним. Он добавляет статическую типизацию. Типы переменных и функций проверяются на этапе компиляции, что улучшает предсказуемость кода. TS Помогает избегать ошибки. Имеет самодокументацию(описывает в объектах какие есть свойства). С помощью TS учшается безопасность кода. Также поддерживает современные возможности ECMAScript. Благодаря явной типизации редакторы могут предоставлять точные подсказки и автодополнение. Например, TS нам сильно поможет понять код, который был давно написан. поможет разобраться в написанном компоненте, вспомнить пропсы и каких они типов. Без TypeScript почти невозможно существование в больших проектах.`,
        categories: ["ts", "all"]
    },
    {
        question: "Отличие Unknown от Any?",
        answer: `any — это тип, который отключает все проверки типизации. Переменные any 
        могут принимать любые значения, и любые операции с ними разрешены. Использование any убирает смысл использования TypeScript. Ошибки проявляются только на этапе выполнения программы.
        unknown — это неизвестный тип, который, как и any, может хранить значения любого типа, но с одним ключевым отличием: мы не сможем выполнять какие-либо операции с переменной типа unknown, пока явно не проверим её тип. Это делает unknown безопасным аналогом any.

        unknown, используется когда нужно работать с переменными, которые могут быть любого типа, но при этом мы хотим обеспечить безопасность и строгость типизации. Например, это может быть полезно в функциях, которые принимают значения от пользователя, API или сторонних библиотек, где нужно тщательно проверять типы перед использованием. Any обычно используется временно  при миграции проекта, во всяких точечных моментах.`,
        categories: ["ts", "all"]
    },
    {
        question: "TypeGuard как реализовать",
        answer: `1) проверка типов(typeof)
        2) if 
        3) Проверить если ли свойство (‘svoistvo’ in obj).
        4)const isSomeObj = (obj: Value): entity is SomeObj => “key” in entity`,
        categories: ["ts", "all"]
    },
    {
        question: "Транспиляция что такое?",
        answer: `Транспиляция - процесс преобразования одной сущности в другую(из TS в JS).`,
        categories: ["ts", "all"]
    },
    {
        question: "Как достать ключи из объекта",
        answer: `keyof Obj`,
        categories: ["ts", "all"]
    },
    {
        question: "Разница между Type и Interface",
        answer: `interface можно расширять с помощью ключевого слова extends, позволяя создавать наследуемые типы.
\n type поддерживает объединение (intersection) и пересечения(union), что позволяет комбинировать несколько типов.
\n interface поддерживает возможность слияния. Если два интерфейса с одним именем объявлены в разных местах, они объединяются в один интерфейс. type не поддерживает слияние. Будет ошибка.
\n interface может описывать только объекты, классы и функции, а type может и примитивные значения`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Omit?",
        answer: `Omit исключает указанные свойства из типа, оставляя остальные`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Pick?",
        answer: `Pick выбирает определённые свойства из объекта и создает новый тип с только этими свойствами.`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Extract",
        answer: `Extract выбирает типы, которые совместимы с переданным типом(то есть которые перескаются)`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Exclude?",
        answer: `Exclude удаляет типы, которые совместимы с переданным типом (то что не входит в объединение).`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Partial и Required?",
        answer: `Partial - длеает ключи необязательным, а Required - обязательно`,
        categories: ["ts", "all"]
    },
    {
        question: "Что делает Record?",
        answer: `Record<string, string | number> - создается тип объекта с фиксированными ключами и значениями определённого типа. первым указываются типы ключей, вторым типы значений.`,
        categories: ["ts", "all"]
    },
    {
        question: "void vs never",
        answer: `void — это тип, указывающий на то, что функция ничего не возвращает, но она может завершиться успешно (например, выполнит свою логику и вернёт undefined).
never — это тип для функций, которые никогда не завершатся нормально, либо из-за выброса ошибки, либо из-за бесконечного выполнения (например, бесконечный цикл)`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое Enum?",
        answer: `В TypeScript enum (перечисление) — это специальный тип данных, который позволяет объявлять набор именованных констант`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое Awaited ?",
        answer: `Awaited — это условный тип, который извлекает тип значения из промиса или объекта, который может быть разрешённым промисом. Это полезно для работы с асинхронными операциями.`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое ReturnType?",
        answer: `ReturnType — это тип, который извлекает тип возвращаемого значения из функции. Это особенно полезно, когда вам нужно знать тип, который возвращает функция, но без явного указания этого типа.`,
        categories: ["ts", "all"]
    },
    {
        question: "Что такое Generics?",
        answer: `Generics — это способ описания функций или интерфейсов, которые могут работать с любым типом данных. Они позволяют писать код, который может принимать любые типы и при этом сохранять типовую безопасность.`,
        categories: ["ts", "all"]
    },
    {
        question: "Какие типы данных есть в JS?",
        answer: `Есть примитивные и объектные типы данных. Примитивных данных всего 7. Это string, number, boolean, null, undefined, symbol, bigInt . Объектные делятся на массивы, объекты, функции. Разница между примитивными и объектными заключается в том, что примитивные данные копируются по значению, а объектные по ссылке.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Как This работает в JS?",
        answer: `Значение this определяется контекстом вызова. this всегда указывает на объект, в контексте которого была вызвана функция. Он не привязывается к функции на этапе её объявления, а определяется в момент вызова.
В строгом режиме (strict mode) внутри функции this будет undefined. В нестрогом режиме оно будет ссылаться на глобальный объект.
В глобальной области, вне функций, this будет ссылаться на глобальный объект: в браузере это Window, а в Node.js это global.
Когда метод вызывается через объект, this указывает на сам объект.
This есть у Function Expression и Function Declaration.
Стрелочные функции не имеют собственного контекста this. Они используют this из внешнего контекста.
Когда вызывается конструктор через new, this указывает на создаваемый объект.
С помощью методов call, apply и bind можно явно установить значение this
call и apply вызывают функцию сразу и позволяют передать контекст. В apply передается массив элементов и контекст. В Call передается элементы через запятую и контекст.
bind возвращает новую функцию с установленным контекстом(в Function Expression или Function Declaration)
В обработчиках событий this указывает на элемент, к которому прикреплен обработчик.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Что такое контекст вызова?",
        answer: `контекст вызова - это объект, к которому привязана функция в момент вызова. This - это ссылка.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Расскажи что такое Class в JS?",
        answer: `класс — это синтаксический сахар над функциями-конструкторами и прототипным наследованием. Классы упрощают создание объектов и работу с наследованием, делая код более читаемым и структурированным.
Классы объявляются с помощью ключевого слова class. Внутри класса можно объявлять методы и конструкторы.
Метод constructor вызывается при создании нового класса и инициализирует объект.
Методы, объявленные внутри класса, автоматически добавляются в прототип объектов, создаваемых этим классом.
Классы могут наследовать друг от друга с помощью ключевого слова extends. Для переопределения и расширения функциональности используется метод super(). Родительский класс называется суперклассом.
Статические методы принадлежат самому классу, а не его экземплярам. Их можно вызывать напрямую через класс.
Классы могут содержать геттеры и сеттеры, которые позволяют управлять доступом к свойствам объекта.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Понятия как __proto__ и prototype",
        answer: `__proto__ — это свойство объекта, которое ссылается на прототип, с которого объект наследует свойства и методы. Является часть цепочки прототипов, по которой JS ищет свойство и методы объекта, если они не найдены в самом объекте. 
Использование Proto является устаревшей и не рекомендуемой практикой.
prototype — это свойство функции конструктора, которое определяет прототип для всех объектов, создаваемых этой функцией.  Когда создается новый объект через конструктор, этот объект получает в качестве своего прототипа значение prototype конструктора. То есть, этот объект будет унаследовать методы и свойства, определенные в prototype. Когда создается новый объект с помощью конструктора, этот объект получает свойство __proto__, которое указывает на prototype конструктора.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "В чем разница между методами класса и статическими методами?",
        answer: `Методы класса принадлежат экземплярам класса, а статические методы — самому классу и не могут быть вызваны через экземпляры.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Как работают геттеры и сеттеры?",
        answer: `Геттеры позволяют вычислять свойства при доступе, а сеттеры — управлять тем, как значения свойств присваиваются.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Что произойдёт, если не вызвать super() в наследуемом классе?",
        answer: `Будет ошибка, так как конструктор дочернего класса должен сначала вызвать конструктор родительского класса.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Function Expression от Function Declaration и стрелочных функции. Разница и отличие.",
        answer: `Function Declaration - это стандартный способ объявления функций в JavaScript. Обычная функция, определенная с использованием ключевого слова function. Особенности: Доступна во всем объеме кода благодаря hoisting (поднятию). Это значит, что можно вызвать функцию до ее определения. Имеет собственный this.
\n Function Expression - Функция, присвоенная переменной. Особенности: Не поднимается (hoisting не применяется), поэтому вызвать функцию до ее объявления невозможно. Имеет собственный контекст this.
\nArrow Function(Стрелочная функция) - Функции со специальным сокращенным синтаксисом. Особенности: Не имеет собственного контекста this, оно наследуется из окружающей области видимости. Не поднимается (hoisting не применяется). Не может быть вызвана с new (не поддерживает конструкторские функции). Нельзя использовать arguments внутри стрелочной функции (оно также наследуется из внешней области). Есть неявный return. Нельзя создавать функцию конструктор.
\n Различия: Стрелочные функции не имеют собственного контекста. Function Declaration поднимаются, Function Expression и стрелочные функции — нет. У стрелочных функций нет псевдомассива аргументс. Function Declaration и Function Expression можно применять call, apply, bind.
\nAnonymous Function (Анонимная функция) - Это функции без имени, часто используется в качестве колбэка. Особенности: Не поднимается. Не имеет имени, поэтому может быть вызвана только через переменную или передана как аргумент.
\nIIFE (Immediately Invoked Function Expression)  - Функция, которая вызывается сразу же после объявления. Часто используется для создания локальной области видимости. Заключается в круглые скобки, чтобы интерпретатор распознал это как выражение.
\nConstructor Function (Конструкторская функция) - Функция, которая используется с ключевым словом new для создания объектов. Особенности: Имеет собственный контекст this, который ссылается на новый созданный объект. Может использоваться для создания экземпляров объектов.
\n Generator Function (Генератор) - Функция, которая может приостанавливать и возобновлять свое выполнение. Особенности: Использует function* синтаксис и yield для пауз и возобновления выполнения.

`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Разница var, let, const?",
        answer: `Разница между var, let, и const заключается в области видимости.
\nvar - Имеет функциональную область видимости. Если var объявлена внутри функции, она видима только в этой функции, но если объявлена вне функции, она становится глобальной. var не имеет блочной области видимости, то есть переменная, объявленная с помощью var внутри блока (например, в цикле for, if, и т.д.), видима за пределами этого блока. Может быть переобъявлена в той же области видимости без ошибок. Может быть объявлена и инициализирована позже. При отсутствии инициализации получает значение undefined.
\nlet и const - Имеют блочную область видимости (block-scoped). Переменные, объявленные с помощью let или const, видимы только в пределах блока, в котором они объявлены. Нельзя переобъявить. Не поднимаются до начала своего объявления. hoisting все равно происходит, но инициализация — нет. Переменную нужно объявить перед использованием, иначе возникнет ошибка ReferenceError. При объявлении через Const  примитивные типы данных нельзя изменить. Но у объектов и массивов можно изменять содержимое.
`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Что такое Всплытие событий?",
        answer: `Всплытие событий (Event Bubbling) - Это когда событие происходит на элементе, оно сначала обрабатывается самим этим элементом, а затем последовательно передается его родительским элементам, поднимаясь по иерархии DOM-дерева вплоть до document.
\nВсплытие можно предотвратить, внутри коллбека которым обрабатывается элемент, написать  event.stopPropagation(), event должен передаваться в колбек.
\nЭтапы обработки событий: Событие в браузере проходит три основных этапа:
\n1)Фаза захвата (Capture phase): Событие идет сверху вниз по дереву DOM к целевому элементу. На этом этапе по умолчанию обработчики не срабатывают, но можно принудительно сделать так, чтобы они срабатывали на этапе захвата, передав третий параметр в методе addEventListener как true.element.addEventListener('click', handler, true);
\n2)Фаза цели (Target phase): Событие доходит до целевого элемента, на котором произошло событие. Обработчики событий этого элемента срабатывают.
\n3)Фаза всплытия (Bubbling phase): Событие поднимается обратно вверх по дереву DOM, срабатывая на всех родительских элементах до document.
`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "В чем разница null, undefined, Undeclared?",
        answer: `undefined - это значение переменной, которая объявлена, но не инициализирована. Также, функция, которая не возвращает значение, автоматически возвращает undefined. Если к объекту или массиву обращаются по несуществующему ключу или индексу, это также даст undefined.
\nnull - это значение, которое явно присваивают, чтобы указать на отсутствие значения.

\nUndeclared. Если ‘use strict’ не включен, то можно писать a = 10, b =10, без использования let,cont,var(это есть синтаксис declared). И переменные добавлятся в объект window. К ним потом можно обратиться Window.a window.b. А Если будет включен, то будет ошибка.`,
        categories: ["platin2", 'js', "all"]
    },
    {
        question: "Из-за чего происходит полное зависание страниц?",
        answer: `1) С Бесконечным цикл While(True) основной поток будет заблокирован, бесконечная рекурсия, Стек будет переполнен и страница зависнет
\n 2)Можем забить стек Microtaskами(создать функцию которая вызывает промис самого себя же). (Очередь микротасков будет выполняться до того момента пока они не закончатся)
\n 3)Если используются promt(диалоговое окошко, с инпутом куда можно ввести значение), alert(с сообщением), confirm. То есть пока они вызваны, страница будет заблокирована`,
        categories: ["platin2", 'js', "all"]
    },

]